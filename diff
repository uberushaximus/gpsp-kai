diff -ru 30_orig/cpu.c 30_new/cpu.c
--- 30_orig/cpu.c	2007-08-26 00:49:55.081782600 +0900
+++ 30_new/cpu.c	2007-08-06 23:46:02.000000000 +0900
@@ -638,7 +638,7 @@
 
 #define arm_multiply_flags_yes(_dest)                                         \
   calculate_z_flag(_dest);                                                    \
-  calculate_n_flag(_dest);                                                    \
+  calculate_n_flag(_dest)                                                     \
 
 #define arm_multiply_flags_no(_dest)                                          \
 
@@ -659,7 +659,7 @@
 }                                                                             \
 
 #define arm_multiply_long_addop(type)                                         \
-  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]));                  \
+  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]))                   \
 
 #define arm_multiply_long(add_op, flags, type)                                \
 {                                                                             \
@@ -1332,7 +1332,7 @@
   address += offset + 4                                                       \
 
 #define thumb_block_address_postadjust_push_lr()                              \
-  store_memory_u32(address + offset, reg[REG_LR]);                            \
+  store_memory_u32(address + offset, reg[REG_LR])                             \
 
 #define thumb_block_memory_wb_load(base_reg)                                  \
   if(!((reg_list >> base_reg) & 0x01))                                        \
@@ -1393,10 +1393,10 @@
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_USER, MODE_FIQ, MODE_IRQ, MODE_SUPERVISOR, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_ABORT, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED, MODE_INVALID, MODE_INVALID,
-  MODE_USER
+  MODE_INVALID, MODE_USER,    MODE_FIQ,     MODE_IRQ,     MODE_SUPERVISOR,
+  MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_ABORT,   MODE_INVALID,
+  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED,MODE_INVALID,MODE_INVALID,
+  MODE_INVALID, MODE_USER
 };
 
 u32 cpu_modes_cpsr[7] = { 0x10, 0x11, 0x12, 0x13, 0x17, 0x1B, 0x1F };
@@ -1888,7 +1888,7 @@
       else                                                                    \
       {                                                                       \
         /* RSC rd, rn, reg_op */                                              \
-        arm_data_proc(reg_sh - reg[rn] + c_flag - 1, reg);                    \
+        arm_data_proc(reg_sh - (reg[rn] + (c_flag ^ 1)), reg);                \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -1921,7 +1921,7 @@
       else                                                                    \
       {                                                                       \
         /* RSCS rd, rn, reg_op */                                             \
-        arm_data_proc_sub_flags((reg_sh + c_flag - 1), reg[rn], reg);         \
+        arm_data_proc_sub_flags(reg_sh, reg[rn] + (c_flag ^ 1), reg);         \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -2351,7 +2351,7 @@
                                                                               \
     case 0x2C:                                                                \
       /* SBC rd, rn, imm */                                                   \
-      arm_data_proc(reg[rn] - imm + c_flag - 1, imm);                         \
+      arm_data_proc(reg[rn] - (imm + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2D:                                                                \
@@ -2361,12 +2361,12 @@
                                                                               \
     case 0x2E:                                                                \
       /* RSC rd, rn, imm */                                                   \
-      arm_data_proc(imm - reg[rn] + c_flag - 1, imm);                         \
+      arm_data_proc(imm - (reg[rn] + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2F:                                                                \
       /* RSCS rd, rn, imm */                                                  \
-      arm_data_proc_sub_flags((imm + c_flag - 1), reg[rn], imm);              \
+      arm_data_proc_sub_flags(imm, reg[rn] + (c_flag ^ 1), imm);              \
       break;                                                                  \
                                                                               \
     case 0x30 ... 0x31:                                                       \
@@ -2919,22 +2919,7 @@
       arm_block_memory(load, up, up, yes);                                    \
       break;                                                                  \
                                                                               \
-    case 0xA0:                                                                \
-    case 0xA1:                                                                \
-    case 0xA2:                                                                \
-    case 0xA3:                                                                \
-    case 0xA4:                                                                \
-    case 0xA5:                                                                \
-    case 0xA6:                                                                \
-    case 0xA7:                                                                \
-    case 0xA8:                                                                \
-    case 0xA9:                                                                \
-    case 0xAA:                                                                \
-    case 0xAB:                                                                \
-    case 0xAC:                                                                \
-    case 0xAD:                                                                \
-    case 0xAE:                                                                \
-    case 0xAF:                                                                \
+    case 0xA0 ... 0xAF:                                                       \
     {                                                                         \
       /* B offset */                                                          \
       arm_decode_branch();                                                    \
@@ -2963,13 +2948,13 @@
       switch(swi_comment >> 16)                                               \
       {                                                                       \
         /* Jump to BIOS SWI handler */                                        \
-        case 0x00 ... 0x2b:                                                   \
+        case 0x00 ... 0x2A:                                                   \
           reg_mode[MODE_SUPERVISOR][6] = pc + 4;                              \
           collapse_flags();                                                   \
           spsr[MODE_SUPERVISOR] = reg[REG_CPSR];                              \
           reg[REG_PC] = 0x00000008;                                           \
           arm_update_pc();                                                    \
-          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x3F) | 0x13;                     \
+          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x1F) | 0x13;                     \
           set_cpu_mode(MODE_SUPERVISOR);                                      \
           break;                                                              \
       }                                                                       \
@@ -3596,7 +3581,7 @@
       thumb_add_noflags(imm, 7, reg[REG_SP], (imm * 4));                      \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
diff -ru 30_orig/cpu_threaded.c 30_new/cpu_threaded.c
--- 30_orig/cpu_threaded.c	2007-08-26 00:49:55.057782600 +0900
+++ 30_new/cpu_threaded.c	2007-08-06 23:45:56.000000000 +0900
@@ -49,7 +49,9 @@
 u32 allow_smc_ram_u8 = 1;
 u32 allow_smc_ram_u16 = 1;
 u32 allow_smc_ram_u32 = 1;
-u32 waitstate_cycles_sequential[16][3];
+u8 waitstate_cycles_seq[2][16];
+u8 waitstate_cycles_non_seq[2][16];
+u8 cpu_waitstate_cycles_seq[2][16];
 
 u32 bios_mode;
 
@@ -78,7 +80,7 @@
   u32 rn = (opcode >> 16) & 0x0F;                                             \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_psr_reg()                                                  \
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
@@ -89,7 +91,7 @@
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_branchx()                                                  \
   u32 rn = opcode & 0x0F                                                      \
@@ -1639,7 +1641,7 @@
     }                                                                         \
   }                                                                           \
                                                                               \
-  pc += 4;                                                                    \
+  pc += 4                                                                     \
 
 #define arm_flag_status()                                                     \
 
@@ -1931,7 +1933,8 @@
                                                                               \
         case 0x01:                                                            \
           /* MUL rd, rs */                                                    \
-          thumb_data_proc(alu_op, muls, reg, rd, rd, rs);                     \
+       /* thumb_data_proc(alu_op, muls, reg, rd, rd, rs); */                  \
+          thumb_data_proc_muls(alu_op, reg, rd, rd, rs);                      \
           break;                                                              \
                                                                               \
         case 0x02:                                                            \
@@ -2246,7 +2249,7 @@
       thumb_load_sp(7);                                                       \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
@@ -2577,9 +2580,17 @@
       }                                                                       \
       break;                                                                  \
                                                                               \
-    /* TST, NEG, CMP, CMN */                                                  \
     case 0x42:                                                                \
-      thumb_flag_modifies_all();                                              \
+      if((opcode >> 6) & 0x03)                                                \
+      {                                                                       \
+        /* NEG, CMP, CMN */                                                   \
+        thumb_flag_modifies_all();                                            \
+      }                                                                       \
+      else                                                                    \
+      {                                                                       \
+        /* TST rd, rs */                                                      \
+        thumb_flag_modifies_zn();                                             \
+      }                                                                       \
       break;                                                                  \
                                                                               \
     /* ORR, MUL, BIC, MVN */                                                  \
@@ -2937,7 +2948,7 @@
 #define arm_instruction_width 4
 
 #define arm_base_cycles()                                                     \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][2]                     \
+  cycle_count += cpu_waitstate_cycles_seq[1][pc >> 24]                        \
 
 // For now this just sets a variable that says flags should always be
 // computed.
@@ -2983,22 +2994,21 @@
   }                                                                           \
   else                                                                        \
                                                                               \
-  if(opcode < 0xF800)                                                         \
+  if(opcode < 0xE800)                                                         \
   {                                                                           \
-    branch_target = block_end_pc + 2 + ((s32)((opcode & 0x7FF) << 21) >> 20); \
+    branch_target = block_end_pc + 2 + (((s32)(opcode & 0x7FF) << 21) >> 20); \
   }                                                                           \
   else                                                                        \
+                                                                              \
+  if((last_opcode >= 0xF000) && (last_opcode < 0xF800))                       \
   {                                                                           \
-    if((last_opcode >= 0xF000) && (last_opcode < 0xF800))                     \
-    {                                                                         \
-      branch_target =                                                         \
-       (block_end_pc + ((s32)((last_opcode & 0x07FF) << 21) >> 9) +           \
-       ((opcode & 0x07FF) * 2));                                              \
-    }                                                                         \
-    else                                                                      \
-    {                                                                         \
-      goto no_direct_branch;                                                  \
-    }                                                                         \
+    branch_target =                                                           \
+     (block_end_pc + (((s32)(last_opcode & 0x07FF) << 21) >> 9) +             \
+     ((s32)(opcode & 0x07FF) * 2));                                           \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    goto no_direct_branch;                                                    \
   }                                                                           \
 
 #define thumb_set_condition(_condition)                                       \
@@ -3012,7 +3022,7 @@
 #define thumb_instruction_width 2
 
 #define thumb_base_cycles()                                                   \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][1]                     \
+  cycle_count += cpu_waitstate_cycles_seq[0][pc >> 24]                        \
 
 // Here's how this works: each instruction has three different sets of flag
 // attributes, each consisiting of a 4bit mask describing how that instruction
@@ -3150,7 +3160,7 @@
     block_data[block_data_position].update_cycles = 0;                        \
     block_data_position++;                                                    \
     if((block_data_position == MAX_BLOCK_SIZE) ||                             \
-     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFFF0))             \
+     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFF0))              \
     {                                                                         \
       break;                                                                  \
     }                                                                         \
diff -ru 30_orig/fbm_print.c 30_new/fbm_print.c
--- 30_orig/fbm_print.c	2007-08-26 00:49:55.001782600 +0900
+++ 30_new/fbm_print.c	2007-08-06 23:47:04.000000000 +0900
@@ -301,7 +301,7 @@
 
 
 	sceDisplayGetMode(&unk, &pwidth, &pheight);
-	sceDisplayGetFrameBuf(&vram, &bufferwidth, &pixelformat, unk);
+	sceDisplayGetFrameBuf(&vram, &bufferwidth, &pixelformat, &unk);
 
 	return fbm_printVRAM(vram, bufferwidth, pixelformat, x, y, str, color, back, fill, rate, 0);
 }
Only in 30_new/: game_config.txt
diff -ru 30_orig/gui.c 30_new/gui.c
--- 30_orig/gui.c	2007-08-26 00:49:55.017782600 +0900
+++ 30_new/gui.c	2007-08-06 23:47:38.000000000 +0900
@@ -1,4 +1,4 @@
- /* unofficial gameplaySP kai
+/* unofficial gameplaySP kai
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
@@ -18,45 +18,256 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/******************************************************************************
+ * gui.c
+ * gui周りの処理
+ ******************************************************************************/
+
+/******************************************************************************
+ * ヘッダファイルの読込み
+ ******************************************************************************/
 #include "common.h"
 
-// Blatantly stolen and trimmed from MZX (megazeux.sourceforge.net)
-
+/******************************************************************************
+ * マクロ等の定義
+ ******************************************************************************/
 #define STATUS_ROWS 0
 #define CURRENT_DIR_ROWS 1
 #define FILE_LIST_ROWS 25
 #define FILE_LIST_POSITION 5
 #define DIR_LIST_POSITION 360
 #define PAGE_SCROLL_NUM 5
+#define GPSP_CONFIG_FILENAME "gpsp.cfg"
 
-#define color16(red, green, blue)                                             \
+#define COLOR16(red, green, blue)                                             \
   (blue << 11) | (green << 5) | red                                           \
 
-#define COLOR_BG            color16(2, 8, 10)
-#define COLOR_ROM_INFO      color16(22, 36, 26)
-#define COLOR_ACTIVE_ITEM   color16(31, 63, 31)
-#define COLOR_INACTIVE_ITEM color16(13, 40, 18)
-#define COLOR_FRAMESKIP_BAR color16(15, 31, 31)
-#define COLOR_HELP_TEXT     color16(16, 40, 24)
-
-char font8[MAX_PATH];
-char font16[MAX_PATH];
-char default_rom_dir[MAX_PATH];
-char default_save_dir[MAX_PATH];
-char default_cfg_dir[MAX_PATH];
-char default_ss_dir[MAX_PATH];
-char default_cheat_dir[MAX_PATH];
+#define COLOR_BG            COLOR16(2, 8, 10)
+#define COLOR_ROM_INFO      COLOR16(22, 36, 26)
+#define COLOR_ACTIVE_ITEM   COLOR16(31, 63, 31)
+#define COLOR_INACTIVE_ITEM COLOR16(13, 40, 18)
+#define COLOR_FRAMESKIP_BAR COLOR16(15, 31, 31)
+#define COLOR_HELP_TEXT     COLOR16(16, 40, 24)
 
-u32 menu_cheat_page = 0;
+#define MAKE_MENU(name, init_function, passive_function)                      \
+  MENU_TYPE name##_menu =                                                     \
+  {                                                                           \
+    init_function,                                                            \
+    passive_function,                                                         \
+    name##_options,                                                           \
+    sizeof(name##_options) / sizeof(MENU_OPTION_TYPE)                         \
+  }                                                                           \
 
-int sort_function(const void *dest_str_ptr, const void *src_str_ptr);
-void _flush_cache();
+#define GAMEPAD_CONFIG_OPTION(display_string, number)                         \
+{                                                                             \
+  NULL,                                                                       \
+  menu_fix_gamepad_help,                                                      \
+  NULL,                                                                       \
+  display_string,                                                             \
+  gamepad_config_buttons,                                                     \
+  gamepad_config_map + gamepad_config_line_to_button[number],                 \
+  sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
+  gamepad_help[gamepad_config_map[                                            \
+   gamepad_config_line_to_button[number]]],                                   \
+  number,                                                                     \
+  STRING_SELECTION_TYPE                                                     \
+}                                                                             \
+
+#define ANALOG_CONFIG_OPTION(display_string, number)                          \
+{                                                                             \
+  NULL,                                                                       \
+  menu_fix_gamepad_help,                                                      \
+  NULL,                                                                       \
+  display_string,                                                             \
+  gamepad_config_buttons,                                                     \
+  gamepad_config_map + number + 12,                                           \
+  sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
+  gamepad_help[gamepad_config_map[number + 12]],                              \
+  number + 2,                                                                 \
+  STRING_SELECTION_TYPE                                                     \
+}                                                                             \
+
+#define CHEAT_OPTION(number)                                                  \
+{                                                                             \
+  NULL,                                                                       \
+  NULL,                                                                       \
+  NULL,                                                                       \
+  cheat_format_str[number],                                                   \
+  enable_disable_options,                                                     \
+  &(game_config_cheats[number].cheat_active),                                 \
+  2,                                                                          \
+  msg[MSG_CHEAT_MENU_HELP_0],                                                 \
+  (number) % 10,                                                              \
+  STRING_SELECTION_TYPE                                                     \
+}                                                                             \
+
+#define ACTION_OPTION(action_function, passive_function, display_string,      \
+ help_string, line_number)                                                    \
+{                                                                             \
+  action_function,                                                            \
+  passive_function,                                                           \
+  NULL,                                                                       \
+  display_string,                                                             \
+  NULL,                                                                       \
+  NULL,                                                                       \
+  0,                                                                          \
+  help_string,                                                                \
+  line_number,                                                                \
+  ACTION_TYPE                                                               \
+}                                                                             \
+
+#define SUBMENU_OPTION(sub_menu, display_string, help_string, line_number)    \
+{                                                                             \
+  NULL,                                                                       \
+  NULL,                                                                       \
+  sub_menu,                                                                   \
+  display_string,                                                             \
+  NULL,                                                                       \
+  NULL,                                                                       \
+  sizeof(sub_menu) / sizeof(MENU_OPTION_TYPE),                                \
+  help_string,                                                                \
+  line_number,                                                                \
+  SUBMENU_TYPE                                                              \
+}                                                                             \
+
+#define SELECTION_OPTION(passive_function, display_string, options,           \
+ option_ptr, num_options, help_string, line_number, type)                     \
+{                                                                             \
+  NULL,                                                                       \
+  passive_function,                                                           \
+  NULL,                                                                       \
+  display_string,                                                             \
+  options,                                                                    \
+  option_ptr,                                                                 \
+  num_options,                                                                \
+  help_string,                                                                \
+  line_number,                                                                \
+  type                                                                        \
+}                                                                             \
+
+#define ACTION_SELECTION_OPTION(action_function, passive_function,            \
+ display_string, options, option_ptr, num_options, help_string, line_number,  \
+ type)                                                                        \
+{                                                                             \
+  action_function,                                                            \
+  passive_function,                                                           \
+  NULL,                                                                       \
+  display_string,                                                             \
+  options,                                                                    \
+  option_ptr,                                                                 \
+  num_options,                                                                \
+  help_string,                                                                \
+  line_number,                                                                \
+  type | ACTION_TYPE                                                        \
+}                                                                             \
+
+#define STRING_SELECTION_OPTION(passive_function, display_string, options,    \
+ option_ptr, num_options, help_string, line_number)                           \
+  SELECTION_OPTION(passive_function, display_string, options,                 \
+   option_ptr, num_options, help_string, line_number, STRING_SELECTION_TYPE)\
+
+#define NUMERIC_SELECTION_OPTION(passive_function, display_string,            \
+ option_ptr, num_options, help_string, line_number)                           \
+  SELECTION_OPTION(passive_function, display_string, NULL, option_ptr,        \
+   num_options, help_string, line_number, NUMBER_SELECTION_TYPE)            \
+
+#define STRING_SELECTION_ACTION_OPTION(action_function, passive_function,     \
+ display_string, options, option_ptr, num_options, help_string, line_number)  \
+  ACTION_SELECTION_OPTION(action_function, passive_function,                  \
+   display_string,  options, option_ptr, num_options, help_string,            \
+   line_number, STRING_SELECTION_TYPE)                                      \
+
+#define NUMERIC_SELECTION_ACTION_OPTION(action_function, passive_function,    \
+ display_string, option_ptr, num_options, help_string, line_number)           \
+  ACTION_SELECTION_OPTION(action_function, passive_function,                  \
+   display_string,  NULL, option_ptr, num_options, help_string,               \
+   line_number, NUMBER_SELECTION_TYPE)                                      \
+
+#define NUMERIC_SELECTION_HIDE_OPTION(action_function,                 \
+ passive_function, display_string, option_ptr, num_options, help_string,      \
+ line_number)                                                                 \
+  ACTION_SELECTION_OPTION(action_function, passive_function,                  \
+   display_string, NULL, option_ptr, num_options, help_string,                \
+   line_number, NUMBER_SELECTION_TYPE)                                      \
 
+#define GAMEPAD_MENU_WIDTH 15
 
+typedef enum
+{
+  NUMBER_SELECTION_TYPE = 0x01,
+  STRING_SELECTION_TYPE = 0x02,
+  SUBMENU_TYPE          = 0x04,
+  ACTION_TYPE           = 0x08
+} menu_option_type_enum;
+
+struct _MENU_TYPE
+{
+  void (* init_function)();
+  void (* passive_function)();
+  struct _MENU_OPTION_TYPE *options;
+  u32 num_options;
+};
 
+struct _MENU_OPTION_TYPE
+{
+  void (* action_function)();
+  void (* passive_function)();
+  struct _MENU_TYPE *sub_menu;
+  char *display_string;
+  void *options;
+  u32 *current_option;
+  u32 num_options;
+  char *help_string;
+  u32 line_number;
+  menu_option_type_enum option_type;
+};
+typedef struct _MENU_OPTION_TYPE MENU_OPTION_TYPE;
 
+typedef enum
+{
+  MAIN_MENU,
+  GAMEPAD_MENU,
+  SAVESTATE_MENU,
+  FRAMESKIP_MENU,
+  CHEAT_MENU,
+  ADHOC_MENU
+} MENU_ENUM;
+typedef struct _MENU_TYPE MENU_TYPE;
+
+/******************************************************************************
+ * グローバル変数の定義
+ ******************************************************************************/
+char DEFAULT_ROM_DIR[MAX_PATH];
+char DEFAULT_SAVE_DIR[MAX_PATH];
+char DEFAULT_CFG_DIR[MAX_PATH];
+char DEFAULT_SS_DIR[MAX_PATH];
+char DEFAULT_CHEAT_DIR[MAX_PATH];
+u32 SAVESTATE_SLOT = 0;
+
+/******************************************************************************
+ * ローカル変数の定義
+ ******************************************************************************/
+static char font8[MAX_PATH];
+static char font16[MAX_PATH];
+static u32 menu_cheat_page = 0;
+static u32 gamepad_config_line_to_button[] = { 8, 6, 7, 9, 1, 2, 3, 0, 4, 5, 11, 10 };
+static u32 clock_speed_number;
+
+/******************************************************************************
+ * ローカル関数の宣言
+ ******************************************************************************/
+static s32 save_game_config_file();
+static s32 save_config_file();
+static void get_savestate_snapshot(char *savestate_filename);
+static void get_savestate_filename(u32 slot, char *name_buffer);
+static int sort_function(const void *dest_str_ptr, const void *src_str_ptr);
+static u32 parse_line(char *current_line, char *current_str);
+static void print_status();
+static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec);
+static void save_ss_bmp(u16 *image);
+void _flush_cache();
 
-int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
+static int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
 {
   char *dest_str = *((char **)dest_str_ptr);
   char *src_str = *((char **)src_str_ptr);
@@ -70,7 +281,12 @@
   return strcasecmp(dest_str, src_str);
 }
 
-// �ėp�t�@�C���Ǎ���
+/******************************************************************************
+ * グローバル関数の定義
+ ******************************************************************************/
+/*--------------------------------------------------------
+  汎用ファイル読込み
+--------------------------------------------------------*/
 s32 load_file(char **wildcards, char *result,char *default_dir_name)
 {
   DIR *current_dir;
@@ -503,189 +719,9 @@
   return return_value;
 }
 
-typedef enum
-{
-  NUMBER_SELECTION_OPTION = 0x01,
-  STRING_SELECTION_OPTION = 0x02,
-  SUBMENU_OPTION          = 0x04,
-  ACTION_OPTION           = 0x08
-} menu_option_type_enum;
-
-struct _menu_type
-{
-  void (* init_function)();
-  void (* passive_function)();
-  struct _menu_option_type *options;
-  u32 num_options;
-};
-
-struct _menu_option_type
-{
-  void (* action_function)();
-  void (* passive_function)();
-  struct _menu_type *sub_menu;
-  char *display_string;
-  void *options;
-  u32 *current_option;
-  u32 num_options;
-  char *help_string;
-  u32 line_number;
-  menu_option_type_enum option_type;
-};
-
-typedef struct _menu_option_type menu_option_type;
-typedef struct _menu_type menu_type;
-
-#define make_menu(name, init_function, passive_function)                      \
-  menu_type name##_menu =                                                     \
-  {                                                                           \
-    init_function,                                                            \
-    passive_function,                                                         \
-    name##_options,                                                           \
-    sizeof(name##_options) / sizeof(menu_option_type)                         \
-  }                                                                           \
-
-#define gamepad_config_option(display_string, number)                         \
-{                                                                             \
-  NULL,                                                                       \
-  menu_fix_gamepad_help,                                                      \
-  NULL,                                                                       \
-  display_string,                                                             \
-  gamepad_config_buttons,                                                     \
-  gamepad_config_map + gamepad_config_line_to_button[number],             \
-  sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
-  gamepad_help[gamepad_config_map[                                            \
-   gamepad_config_line_to_button[number]]],                               \
-  number,                                                                     \
-  STRING_SELECTION_OPTION                                                     \
-}                                                                             \
-
-#define analog_config_option(display_string, number)                          \
-{                                                                             \
-  NULL,                                                                       \
-  menu_fix_gamepad_help,                                                      \
-  NULL,                                                                       \
-  display_string,                                                             \
-  gamepad_config_buttons,                                                     \
-  gamepad_config_map + number + 12,                                           \
-  sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
-  gamepad_help[gamepad_config_map[number + 12]],                              \
-  number + 2,                                                                 \
-  STRING_SELECTION_OPTION                                                     \
-}                                                                             \
-
-#define cheat_option(number)                                                  \
-{                                                                             \
-  NULL,                                                                       \
-  NULL,                                                                       \
-  NULL,                                                                       \
-  cheat_format_str[number],                                                   \
-  enable_disable_options,                                                     \
-  &(game_config_cheats[number].cheat_active),                                 \
-  2,                                                                          \
-  msg[MSG_CHEAT_MENU_HELP_0],                                                 \
-  (number) % 10,                                                              \
-  STRING_SELECTION_OPTION                                                     \
-}                                                                             \
-
-#define action_option(action_function, passive_function, display_string,      \
- help_string, line_number)                                                    \
-{                                                                             \
-  action_function,                                                            \
-  passive_function,                                                           \
-  NULL,                                                                       \
-  display_string,                                                             \
-  NULL,                                                                       \
-  NULL,                                                                       \
-  0,                                                                          \
-  help_string,                                                                \
-  line_number,                                                                \
-  ACTION_OPTION                                                               \
-}                                                                             \
-
-#define submenu_option(sub_menu, display_string, help_string, line_number)    \
-{                                                                             \
-  NULL,                                                                       \
-  NULL,                                                                       \
-  sub_menu,                                                                   \
-  display_string,                                                             \
-  NULL,                                                                       \
-  NULL,                                                                       \
-  sizeof(sub_menu) / sizeof(menu_option_type),                                \
-  help_string,                                                                \
-  line_number,                                                                \
-  SUBMENU_OPTION                                                              \
-}                                                                             \
-
-#define selection_option(passive_function, display_string, options,           \
- option_ptr, num_options, help_string, line_number, type)                     \
-{                                                                             \
-  NULL,                                                                       \
-  passive_function,                                                           \
-  NULL,                                                                       \
-  display_string,                                                             \
-  options,                                                                    \
-  option_ptr,                                                                 \
-  num_options,                                                                \
-  help_string,                                                                \
-  line_number,                                                                \
-  type                                                                        \
-}                                                                             \
-
-#define action_selection_option(action_function, passive_function,            \
- display_string, options, option_ptr, num_options, help_string, line_number,  \
- type)                                                                        \
-{                                                                             \
-  action_function,                                                            \
-  passive_function,                                                           \
-  NULL,                                                                       \
-  display_string,                                                             \
-  options,                                                                    \
-  option_ptr,                                                                 \
-  num_options,                                                                \
-  help_string,                                                                \
-  line_number,                                                                \
-  type | ACTION_OPTION                                                        \
-}                                                                             \
-
-
-#define string_selection_option(passive_function, display_string, options,    \
- option_ptr, num_options, help_string, line_number)                           \
-  selection_option(passive_function, display_string, options,                 \
-   option_ptr, num_options, help_string, line_number, STRING_SELECTION_OPTION)\
-
-#define numeric_selection_option(passive_function, display_string,            \
- option_ptr, num_options, help_string, line_number)                           \
-  selection_option(passive_function, display_string, NULL, option_ptr,        \
-   num_options, help_string, line_number, NUMBER_SELECTION_OPTION)            \
-
-#define string_selection_action_option(action_function, passive_function,     \
- display_string, options, option_ptr, num_options, help_string, line_number)  \
-  action_selection_option(action_function, passive_function,                  \
-   display_string,  options, option_ptr, num_options, help_string,            \
-   line_number, STRING_SELECTION_OPTION)                                      \
-
-#define numeric_selection_action_option(action_function, passive_function,    \
- display_string, option_ptr, num_options, help_string, line_number)           \
-  action_selection_option(action_function, passive_function,                  \
-   display_string,  NULL, option_ptr, num_options, help_string,               \
-   line_number, NUMBER_SELECTION_OPTION)                                      \
-
-#define numeric_selection_action_hide_option(action_function,                 \
- passive_function, display_string, option_ptr, num_options, help_string,      \
- line_number)                                                                 \
-  action_selection_option(action_function, passive_function,                  \
-   display_string, NULL, option_ptr, num_options, help_string,                \
-   line_number, NUMBER_SELECTION_OPTION)                                      \
-
-
-#define GAMEPAD_MENU_WIDTH 15
-
-u32 gamepad_config_line_to_button[] =
- { 8, 6, 7, 9, 1, 2, 3, 0, 4, 5, 11, 10 };
-
-
-// �Q�[�����Ƃ�cfg�t�@�C���̓Ǎ���
+/*--------------------------------------------------------
+  game cfgファイルの読込み
+--------------------------------------------------------*/
 s32 load_game_config_file()
 {
   char game_config_filename[MAX_FILE];
@@ -695,8 +731,8 @@
 
   change_ext(gamepak_filename, game_config_filename, ".cfg");
 
-  if (default_cfg_dir != NULL) {
-    sprintf(game_config_path, "%s/%s", default_cfg_dir, game_config_filename);
+  if (DEFAULT_CFG_DIR != NULL) {
+    sprintf(game_config_path, "%s/%s", DEFAULT_CFG_DIR, game_config_filename);
   }
   else
   {
@@ -726,6 +762,10 @@
       if(game_config_clock_speed < 33)
         game_config_clock_speed = 33;
 
+      /* メニュー終了時は clock_speed_number を元にクロックが変更される */
+      /* 起動時のファイルリストからの場合は、game_config_clock_speed */
+      clock_speed_number = (game_config_clock_speed / 33) - 1;
+
       if(game_config_frameskip_value < 0)
         game_config_frameskip_value = 0;
 
@@ -743,11 +783,13 @@
     }
   }
 
-  // �ǂݍ��߂Ȃ��B��ꍇ�̏���l�̐ݒ�
+  // 読み込めなかった場合の初期値の設定
   game_config_frameskip_type = auto_frameskip;
-  game_config_frameskip_value = 4;
+  /* 一瞬負荷が上がる場合、スキップを増やした方がスムーズに動作する。 */
+  game_config_frameskip_value = 9;
   game_config_random_skip = 0;
   game_config_clock_speed = 333;
+  clock_speed_number = 9;
 
   for(i = 0; i < MAX_CHEATS; i++)
   {
@@ -758,6 +800,9 @@
   return -1;
 }
 
+/*--------------------------------------------------------
+  gpSP cfgファイルの読込み
+--------------------------------------------------------*/
 s32 load_config_file()
 {
   char config_path[512];
@@ -783,215 +828,48 @@
       screen_filter = file_options[1] % 2;
       global_enable_audio = file_options[2] % 2;
       audio_buffer_size_number = file_options[3] % 11;
-      update_backup_flag = file_options[4] % 2;
-      global_enable_analog = file_options[5] % 2;
-      analog_sensitivity_level = file_options[6] % 8;
-
-      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
-
-      // Sanity check: Make sure there's a MENU or FRAMESKIP
-      // key, if not assign to triangle
-
-      for(i = 0; i < 16; i++)
-      {
-        gamepad_config_map[i] = file_options[7 + i] %
-         (BUTTON_ID_NONE + 1);
-
-        if(gamepad_config_map[i] == BUTTON_ID_MENU)
-        {
-          menu_button = i;
-        }
-      }
-
-      if(menu_button == -1)
-      {
-        gamepad_config_map[0] = BUTTON_ID_MENU;
-      }
-
-      FILE_CLOSE(config_file);
-    }
-
-    return 0;
-  }
-
-  return -1;
-}
-
-s32 save_game_config_file()
-{
-  char game_config_filename[MAX_FILE];
-  char game_config_path[MAX_PATH];
-  u32 i;
-  FILE_ID game_config_file;
-
-  if(gamepak_filename[0] == 0) return -1;
-
-  change_ext(gamepak_filename, game_config_filename, ".cfg");
-
-  if (default_cfg_dir != NULL) {
-    sprintf(game_config_path, "%s/%s", default_cfg_dir, game_config_filename);
-  }
-  else
-  {
-    strcpy(game_config_path, game_config_filename);
-  }
-
-  FILE_OPEN(game_config_file, game_config_path, WRITE);
-  if(FILE_CHECK_VALID(game_config_file))
-  {
-    u32 file_options[4 + MAX_CHEATS];
-
-    file_options[0] = game_config_frameskip_type;
-    file_options[1] = game_config_frameskip_value;
-    file_options[2] = game_config_random_skip;
-    file_options[3] = game_config_clock_speed;
-
-    for(i = 0; i < MAX_CHEATS; i++)
-    {
-      file_options[4 + i] = game_config_cheats[i].cheat_active;
-    }
-
-    FILE_WRITE_ARRAY(game_config_file, file_options);
-    FILE_CLOSE(game_config_file);
-
-    return 0;
-  }
-
-  return -1;
-}
-
-s32 save_config_file()
-{
-  char config_path[512];
-  FILE_ID config_file;
-
-  sprintf(config_path, "%s/%s", main_path, GPSP_CONFIG_FILENAME);
-
-  FILE_OPEN(config_file, config_path, WRITE);
-
-  save_game_config_file();
-
-  if(FILE_CHECK_VALID(config_file))
-  {
-    u32 file_options[23];
-    u32 i;
-
-    file_options[0] = screen_scale;
-    file_options[1] = screen_filter;
-    file_options[2] = global_enable_audio;
-    file_options[3] = audio_buffer_size_number;
-    file_options[4] = update_backup_flag;
-    file_options[5] = global_enable_analog;
-    file_options[6] = analog_sensitivity_level;
-
-    for(i = 0; i < 16; i++)
-    {
-      file_options[7 + i] = gamepad_config_map[i];
-    }
-
-    FILE_WRITE_ARRAY(config_file, file_options);
-    FILE_CLOSE(config_file);
-
-    return 0;
-  }
-
-  return -1;
-}
-
-typedef enum
-{
-  MAIN_MENU,
-  GAMEPAD_MENU,
-  SAVESTATE_MENU,
-  FRAMESKIP_MENU,
-  CHEAT_MENU
-} menu_enum;
-
-u32 savestate_slot = 0;
-
-void get_savestate_snapshot(char *savestate_filename)
-{
-  u16 snapshot_buffer[240 * 160];
-  char savestate_timestamp_string[80];
-  char savestate_path[1024];
-  FILE_ID savestate_file;
-
-  if (default_save_dir != NULL) {
-    sprintf(savestate_path, "%s/%s", default_save_dir, savestate_filename);
-  }
-  else
-  {
-    strcpy(savestate_path, savestate_filename);
-  }
-
-  FILE_OPEN(savestate_file, savestate_path, READ);
-
-  if(FILE_CHECK_VALID(savestate_file))
-  {
-    time_t savestate_time_flat;
-    time_t local_time;
-//    u64 utc;
-//    u64 local;
-    int time_diff;
-    struct tm *current_time;
-    FILE_READ_ARRAY(savestate_file, snapshot_buffer);
-    FILE_READ_VARIABLE(savestate_file, savestate_time_flat);
-
-    FILE_CLOSE(savestate_file);
-
-    sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_TIMEZONE,&time_diff);
-    local_time = savestate_time_flat + (time_diff * 60);
-
-    current_time = localtime(&local_time);
-
-    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_FMT_0, current_time->tm_year + 1900, current_time->tm_mon + 1, current_time->tm_mday,
-      current_time->tm_wday, current_time->tm_hour, current_time->tm_min, current_time->tm_sec, 0);
+      update_backup_flag = file_options[4] % 2;
+      global_enable_analog = file_options[5] % 2;
+      analog_sensitivity_level = file_options[6] % 10;
 
-    savestate_timestamp_string[40] = 0;
+      /* 何故ここで変更しているのか不明。*/
+      /* config_fileが存在しないとクロックは変更されない。*/
+//      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
 
-    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
-  }
-  else
-  {
-    memset(snapshot_buffer, 0, 240 * 160 * 2);
-    print_string_ext(msg[MSG_STATE_MENU_STATE_NONE], 0xFFFF, 0x0000, 15, 75, snapshot_buffer, 240, 0);
-    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_NONE_0, 0, 0, 0, 0, 0, 0, 0, 0);
-    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
-  }
-  blit_to_screen(snapshot_buffer, 240, 160, 230, 40);
-}
+      // Sanity check: Make sure there's a MENU or FRAMESKIP
+      // key, if not assign to triangle
 
-void get_savestate_filename(u32 slot, char *name_buffer)
-{
-  char savestate_ext[16];
+      for(i = 0; i < 16; i++)
+      {
+        gamepad_config_map[i] = file_options[7 + i] %
+         (BUTTON_ID_NONE + 1);
 
-  sprintf(savestate_ext, "_%d.svs", (int)slot);
-  change_ext(gamepak_filename, name_buffer, savestate_ext);
+        if(gamepad_config_map[i] == BUTTON_ID_MENU)
+        {
+          menu_button = i;
+        }
+      }
 
-  get_savestate_snapshot(name_buffer);
-}
+      if(menu_button == -1)
+      {
+        gamepad_config_map[0] = BUTTON_ID_MENU;
+      }
 
-void get_savestate_filename_noshot(u32 slot, char *name_buffer)
-{
-  char savestate_ext[16];
+      FILE_CLOSE(config_file);
+    }
 
-  sprintf(savestate_ext, "_%d.svs", (int)slot);
-  change_ext(gamepak_filename, name_buffer, savestate_ext);
-}
+    return 0;
+  }
 
-void _flush_cache()
-{
-//    sceKernelDcacheWritebackAll();
-    invalidate_all_cache();
+  return -1;
 }
 
 u32 menu(u16 *original_screen)
 {
-  u32 clock_speed_number = (game_config_clock_speed / 33) - 1;
   char print_buffer[81];
 //  u32 _current_option = 0;
   gui_action_type gui_action;
-//  menu_enum _current_menu = MAIN_MENU;
+//  MENU_ENUM _current_menu = MAIN_MENU;
   u32 i;
   u32 repeat = 1;
   u32 return_value = 0;
@@ -1001,9 +879,9 @@
   char line_buffer[80];
   char cheat_format_str[MAX_CHEATS][41];
 
-  menu_type *current_menu;
-  menu_option_type *current_option;
-  menu_option_type *display_option;
+  MENU_TYPE *current_menu;
+  MENU_OPTION_TYPE *current_option;
+  MENU_OPTION_TYPE *display_option;
   u32 current_option_num;
 
   SceCtrlData ctrl_data;
@@ -1078,7 +956,7 @@
 //    if(!update_backup_flag)
       update_backup_force();
 
-    if(load_file(file_ext, load_filename, default_rom_dir) != -1)
+    if(load_file(file_ext, load_filename, DEFAULT_ROM_DIR) != -1)
     {
        if(load_gamepak(load_filename) == -1)
        {
@@ -1108,19 +986,21 @@
 
   void menu_save_ss()
   {
-    save_ss_bmp(original_screen);
+    /* 「未ロード．」のスクリーンショットが出来上がります。 */
+    if(!first_load)
+      save_ss_bmp(original_screen);
   }
 
   void menu_change_state()
   {
-    get_savestate_filename(savestate_slot, current_savestate_filename);
+    get_savestate_filename(SAVESTATE_SLOT, current_savestate_filename);
   }
 
   void menu_save_state()
   {
     if(!first_load)
     {
-      get_savestate_filename_noshot(savestate_slot,
+      get_savestate_filename_noshot(SAVESTATE_SLOT,
        current_savestate_filename);
       save_state(current_savestate_filename, original_screen);
     }
@@ -1141,7 +1021,8 @@
   {
     char *file_ext[] = { ".svs", NULL };
     char load_filename[512];
-    if(load_file(file_ext, load_filename, default_save_dir) != -1)
+
+    if(load_file(file_ext, load_filename, DEFAULT_SAVE_DIR) != -1)
     {
       load_state(load_filename);
       return_value = 1;
@@ -1153,14 +1034,14 @@
     }
   }
 
-  // ���j���[:�`�[�g�t�@�C���̃��[�h
+  // メニュー:チートファイルのロード
   void menu_load_cheat_file()
   {
     char *file_ext[] = { ".cht", NULL };
     char load_filename[MAX_FILE];
-    u32 i;
+//    u32 i;
     
-    if(load_file(file_ext, load_filename, default_cheat_dir) != -1)
+    if(load_file(file_ext, load_filename, DEFAULT_CHEAT_DIR) != -1)
     {
       add_cheats(load_filename);
       for(i = 0; i < MAX_CHEATS; i++)
@@ -1227,7 +1108,7 @@
      gamepak_code, gamepak_maker);
     print_string(print_buffer, COLOR_ROM_INFO, COLOR_BG, 10, 20);
 
-    get_savestate_filename_noshot(savestate_slot,
+    get_savestate_filename_noshot(SAVESTATE_SLOT,
      current_savestate_filename);
   }
 
@@ -1283,130 +1164,146 @@
     msg[MSG_PAD_MENU_CFG_21],
   };
 
-  // Marker for help information, don't go past this mark (except \n)------*
-  menu_option_type graphics_sound_options[] =
+  /*--------------------------------------------------------
+     グラフィック・サウンド オプション
+  --------------------------------------------------------*/
+  MENU_OPTION_TYPE graphics_sound_options[] =
   {
-    string_selection_option(NULL, msg[MSG_G_S_MENU_0], scale_options, &screen_scale, 3, msg[MSG_G_S_MENU_HELP_0], 2),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_0], scale_options, &screen_scale, 3, msg[MSG_G_S_MENU_HELP_0], 2),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_1], yes_no_options, &screen_filter, 2, msg[MSG_G_S_MENU_HELP_1], 3),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_1], yes_no_options, &screen_filter, 2, msg[MSG_G_S_MENU_HELP_1], 3),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_2], frameskip_options, &game_config_frameskip_type, 3, msg[MSG_G_S_MENU_HELP_2], 5),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_2], frameskip_options, &game_config_frameskip_type, 3, msg[MSG_G_S_MENU_HELP_2], 5),
 
-    numeric_selection_option(NULL, msg[MSG_G_S_MENU_3], &game_config_frameskip_value, 100, msg[MSG_G_S_MENU_HELP_3], 6),
+    NUMERIC_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_3], &game_config_frameskip_value, 100, msg[MSG_G_S_MENU_HELP_3], 6),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_4], frameskip_variation_options, &game_config_random_skip, 2, msg[MSG_G_S_MENU_HELP_4], 7),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_4], frameskip_variation_options, &game_config_random_skip, 2, msg[MSG_G_S_MENU_HELP_4], 7),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_G_S_MENU_HELP_5], 9),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_G_S_MENU_HELP_5], 9),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 10, msg[MSG_G_S_MENU_HELP_6], 11),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 11, msg[MSG_G_S_MENU_HELP_6], 11),
 
-    action_option(menu_save_ss, NULL, msg[MSG_G_S_MENU_7], msg[MSG_G_S_MENU_HELP_7], 12),
+    ACTION_OPTION(menu_save_ss, NULL, msg[MSG_G_S_MENU_7], msg[MSG_G_S_MENU_HELP_7], 12),
 
-    submenu_option(NULL, msg[MSG_G_S_MENU_8], msg[MSG_G_S_MENU_HELP_8], 14)
+    SUBMENU_OPTION(NULL, msg[MSG_G_S_MENU_8], msg[MSG_G_S_MENU_HELP_8], 14)
   };
 
-  make_menu(graphics_sound, submenu_graphics_sound, NULL);
+  MAKE_MENU(graphics_sound, submenu_graphics_sound, NULL);
 
-  menu_option_type cheats_misc_options[] =
+  /*--------------------------------------------------------
+     チート オプション
+  --------------------------------------------------------*/
+  MENU_OPTION_TYPE cheats_misc_options[] =
   {
-    cheat_option((10 * menu_cheat_page) + 0),
-    cheat_option((10 * menu_cheat_page) + 1),
-    cheat_option((10 * menu_cheat_page) + 2),
-    cheat_option((10 * menu_cheat_page) + 3),
-    cheat_option((10 * menu_cheat_page) + 4),
-    cheat_option((10 * menu_cheat_page) + 5),
-    cheat_option((10 * menu_cheat_page) + 6),
-    cheat_option((10 * menu_cheat_page) + 7),
-    cheat_option((10 * menu_cheat_page) + 8),
-    cheat_option((10 * menu_cheat_page) + 9),
+    CHEAT_OPTION((10 * menu_cheat_page) + 0),
+    CHEAT_OPTION((10 * menu_cheat_page) + 1),
+    CHEAT_OPTION((10 * menu_cheat_page) + 2),
+    CHEAT_OPTION((10 * menu_cheat_page) + 3),
+    CHEAT_OPTION((10 * menu_cheat_page) + 4),
+    CHEAT_OPTION((10 * menu_cheat_page) + 5),
+    CHEAT_OPTION((10 * menu_cheat_page) + 6),
+    CHEAT_OPTION((10 * menu_cheat_page) + 7),
+    CHEAT_OPTION((10 * menu_cheat_page) + 8),
+    CHEAT_OPTION((10 * menu_cheat_page) + 9),
 
-    numeric_selection_option(reload_cheats_page, "cheat page: %d", &menu_cheat_page, MAX_CHEATS_PAGE, "cheat page", 10),
+    NUMERIC_SELECTION_OPTION(reload_cheats_page, "cheat page: %d", &menu_cheat_page, MAX_CHEATS_PAGE, "cheat page", 10),
 
-    action_option(menu_load_cheat_file, NULL, msg[MSG_CHEAT_MENU_1], msg[MSG_CHEAT_MENU_HELP_1], 11), 
+    ACTION_OPTION(menu_load_cheat_file, NULL, msg[MSG_CHEAT_MENU_1], msg[MSG_CHEAT_MENU_HELP_1], 11), 
 
-    string_selection_option(NULL, msg[MSG_CHEAT_MENU_2], clock_speed_options, &clock_speed_number, 10, msg[MSG_CHEAT_MENU_HELP_2], 13), 
+    STRING_SELECTION_OPTION(NULL, msg[MSG_CHEAT_MENU_2], clock_speed_options, &clock_speed_number, 10, msg[MSG_CHEAT_MENU_HELP_2], 13), 
 
-    string_selection_option(NULL, msg[MSG_CHEAT_MENU_3], update_backup_options, &update_backup_flag, 2, msg[MSG_CHEAT_MENU_HELP_3], 14), 
+    STRING_SELECTION_OPTION(NULL, msg[MSG_CHEAT_MENU_3], update_backup_options, &update_backup_flag, 2, msg[MSG_CHEAT_MENU_HELP_3], 14), 
 
-    submenu_option(NULL, msg[MSG_CHEAT_MENU_4], msg[MSG_CHEAT_MENU_HELP_4], 16) 
+    SUBMENU_OPTION(NULL, msg[MSG_CHEAT_MENU_4], msg[MSG_CHEAT_MENU_HELP_4], 16) 
   };
 
-  make_menu(cheats_misc, submenu_cheats_misc, NULL);
+  MAKE_MENU(cheats_misc, submenu_cheats_misc, NULL);
 
-  menu_option_type savestate_options[] =
+  /*--------------------------------------------------------
+     セーブステート オプション
+  --------------------------------------------------------*/
+  MENU_OPTION_TYPE savestate_options[] =
   {
-    numeric_selection_action_hide_option(menu_load_state, menu_change_state, msg[MSG_STATE_MENU_0], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_0], 6),
+    NUMERIC_SELECTION_HIDE_OPTION(menu_load_state, menu_change_state, msg[MSG_STATE_MENU_0], &SAVESTATE_SLOT, 10, msg[MSG_STATE_MENU_HELP_0], 6),
 
-    numeric_selection_action_hide_option(menu_save_state, menu_change_state, msg[MSG_STATE_MENU_1], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_1], 7),
+    NUMERIC_SELECTION_HIDE_OPTION(menu_save_state, menu_change_state, msg[MSG_STATE_MENU_1], &SAVESTATE_SLOT, 10, msg[MSG_STATE_MENU_HELP_1], 7),
 
-    numeric_selection_action_hide_option(menu_load_state_file, menu_change_state, msg[MSG_STATE_MENU_2], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_2], 9),
+    NUMERIC_SELECTION_HIDE_OPTION(menu_load_state_file, menu_change_state, msg[MSG_STATE_MENU_2], &SAVESTATE_SLOT, 10, msg[MSG_STATE_MENU_HELP_2], 9),
 
-    numeric_selection_option(menu_change_state, msg[MSG_STATE_MENU_3], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_3], 11),
+    NUMERIC_SELECTION_OPTION(menu_change_state, msg[MSG_STATE_MENU_3], &SAVESTATE_SLOT, 10, msg[MSG_STATE_MENU_HELP_3], 11),
 
-    submenu_option(NULL, msg[MSG_STATE_MENU_4], msg[MSG_STATE_MENU_HELP_4], 13)
+    SUBMENU_OPTION(NULL, msg[MSG_STATE_MENU_4], msg[MSG_STATE_MENU_HELP_4], 13)
   };
 
-  make_menu(savestate, submenu_savestate, NULL);
+  MAKE_MENU(savestate, submenu_savestate, NULL);
 
-  menu_option_type gamepad_config_options[] =
-  {
-    gamepad_config_option(msg[MSG_PAD_MENU_0], 0),
-    gamepad_config_option(msg[MSG_PAD_MENU_1], 1),
-    gamepad_config_option(msg[MSG_PAD_MENU_2], 2),
-    gamepad_config_option(msg[MSG_PAD_MENU_3], 3),
-    gamepad_config_option(msg[MSG_PAD_MENU_4], 4),
-    gamepad_config_option(msg[MSG_PAD_MENU_5], 5),
-    gamepad_config_option(msg[MSG_PAD_MENU_6], 6),
-    gamepad_config_option(msg[MSG_PAD_MENU_7], 7),
-    gamepad_config_option(msg[MSG_PAD_MENU_8], 8),
-    gamepad_config_option(msg[MSG_PAD_MENU_9], 9),
-    gamepad_config_option(msg[MSG_PAD_MENU_10], 10),
-    gamepad_config_option(msg[MSG_PAD_MENU_11], 11),
-    submenu_option(NULL, msg[MSG_PAD_MENU_12], msg[MSG_PAD_MENU_HELP_0], 13)
+  /*--------------------------------------------------------
+     ゲームパッド オプション
+  --------------------------------------------------------*/
+  MENU_OPTION_TYPE gamepad_config_options[] =
+  {
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_0], 0),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_1], 1),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_2], 2),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_3], 3),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_4], 4),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_5], 5),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_6], 6),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_7], 7),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_8], 8),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_9], 9),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_10], 10),
+    GAMEPAD_CONFIG_OPTION(msg[MSG_PAD_MENU_11], 11),
+
+    SUBMENU_OPTION(NULL, msg[MSG_PAD_MENU_12], msg[MSG_PAD_MENU_HELP_0], 13)
   };
 
-  menu_option_type analog_config_options[] =
-  {
-    analog_config_option(msg[MSG_A_PAD_MENU_0], 0),
-    analog_config_option(msg[MSG_A_PAD_MENU_1], 1),
-    analog_config_option(msg[MSG_A_PAD_MENU_2], 2),
-    analog_config_option(msg[MSG_A_PAD_MENU_3], 3),
-    string_selection_option(NULL, msg[MSG_A_PAD_MENU_4], yes_no_options, &global_enable_analog, 2, msg[MSG_A_PAD_MENU_HELP_0], 7),
-    numeric_selection_option(NULL, msg[MSG_A_PAD_MENU_5], &analog_sensitivity_level, 10, msg[MSG_A_PAD_MENU_HELP_1], 8),
-    submenu_option(NULL, msg[MSG_A_PAD_MENU_6], msg[MSG_A_PAD_MENU_HELP_2], 11)
+  MAKE_MENU(gamepad_config, submenu_gamepad, NULL);
+
+  /*--------------------------------------------------------
+     アナログパッド オプション
+  --------------------------------------------------------*/
+  MENU_OPTION_TYPE analog_config_options[] =
+  {
+    ANALOG_CONFIG_OPTION(msg[MSG_A_PAD_MENU_0], 0),
+    ANALOG_CONFIG_OPTION(msg[MSG_A_PAD_MENU_1], 1),
+    ANALOG_CONFIG_OPTION(msg[MSG_A_PAD_MENU_2], 2),
+    ANALOG_CONFIG_OPTION(msg[MSG_A_PAD_MENU_3], 3),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_A_PAD_MENU_4], yes_no_options, &global_enable_analog, 2, msg[MSG_A_PAD_MENU_HELP_0], 7),
+    NUMERIC_SELECTION_OPTION(NULL, msg[MSG_A_PAD_MENU_5], &analog_sensitivity_level, 10, msg[MSG_A_PAD_MENU_HELP_1], 8),
+    SUBMENU_OPTION(NULL, msg[MSG_A_PAD_MENU_6], msg[MSG_A_PAD_MENU_HELP_2], 11)
   };
 
-  make_menu(gamepad_config, submenu_gamepad, NULL);
-  make_menu(analog_config, submenu_analog, NULL);
+  MAKE_MENU(analog_config, submenu_analog, NULL);
 
-  menu_option_type main_options[] =
+  MENU_OPTION_TYPE main_options[] =
   {
-    submenu_option(&graphics_sound_menu, msg[MSG_MAIN_MENU_0], msg[MSG_MAIN_MENU_HELP_0], 0), 
+    SUBMENU_OPTION(&graphics_sound_menu, msg[MSG_MAIN_MENU_0], msg[MSG_MAIN_MENU_HELP_0], 0), 
 
-    numeric_selection_action_option(menu_load_state, NULL, msg[MSG_MAIN_MENU_1], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_1], 2),
+    NUMERIC_SELECTION_ACTION_OPTION(menu_load_state, NULL, msg[MSG_MAIN_MENU_1], &SAVESTATE_SLOT, 10, msg[MSG_MAIN_MENU_HELP_1], 2),
 
-    numeric_selection_action_option(menu_save_state, NULL, msg[MSG_MAIN_MENU_2], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_2], 3),
+    NUMERIC_SELECTION_ACTION_OPTION(menu_save_state, NULL, msg[MSG_MAIN_MENU_2], &SAVESTATE_SLOT, 10, msg[MSG_MAIN_MENU_HELP_2], 3),
 
-    submenu_option(&savestate_menu, msg[MSG_MAIN_MENU_3], msg[MSG_MAIN_MENU_HELP_3], 4),
+    SUBMENU_OPTION(&savestate_menu, msg[MSG_MAIN_MENU_3], msg[MSG_MAIN_MENU_HELP_3], 4),
 
-    submenu_option(&gamepad_config_menu, msg[MSG_MAIN_MENU_4], msg[MSG_MAIN_MENU_HELP_4], 6),
+    SUBMENU_OPTION(&gamepad_config_menu, msg[MSG_MAIN_MENU_4], msg[MSG_MAIN_MENU_HELP_4], 6),
 
-    submenu_option(&analog_config_menu, msg[MSG_MAIN_MENU_5], msg[MSG_MAIN_MENU_HELP_5], 7),
+    SUBMENU_OPTION(&analog_config_menu, msg[MSG_MAIN_MENU_5], msg[MSG_MAIN_MENU_HELP_5], 7),
 
-    submenu_option(&cheats_misc_menu, msg[MSG_MAIN_MENU_6], msg[MSG_MAIN_MENU_HELP_6], 9),
+    SUBMENU_OPTION(&cheats_misc_menu, msg[MSG_MAIN_MENU_6], msg[MSG_MAIN_MENU_HELP_6], 9),
 
-    action_option(menu_load, NULL, msg[MSG_MAIN_MENU_7], msg[MSG_MAIN_MENU_HELP_7], 11),
+    ACTION_OPTION(menu_load, NULL, msg[MSG_MAIN_MENU_7], msg[MSG_MAIN_MENU_HELP_7], 11),
 
-    action_option(menu_restart, NULL, msg[MSG_MAIN_MENU_8], msg[MSG_MAIN_MENU_HELP_8], 12), 
+    ACTION_OPTION(menu_restart, NULL, msg[MSG_MAIN_MENU_8], msg[MSG_MAIN_MENU_HELP_8], 12), 
 
-    action_option(menu_exit, NULL, msg[MSG_MAIN_MENU_9], msg[MSG_MAIN_MENU_HELP_9], 13), 
+    ACTION_OPTION(menu_exit, NULL, msg[MSG_MAIN_MENU_9], msg[MSG_MAIN_MENU_HELP_9], 13), 
 
-    action_option(menu_quit, NULL, msg[MSG_MAIN_MENU_10], msg[MSG_MAIN_MENU_HELP_10], 15) 
+    ACTION_OPTION(menu_quit, NULL, msg[MSG_MAIN_MENU_10], msg[MSG_MAIN_MENU_HELP_10], 15) 
   };
 
-  make_menu(main, submenu_main, NULL);
+  MAKE_MENU(main, submenu_main, NULL);
 
-  void choose_menu(menu_type *new_menu)
+  void choose_menu(MENU_TYPE *new_menu)
   {
     if(new_menu == NULL)
       new_menu = &main_menu;
@@ -1415,6 +1312,7 @@
     blit_to_screen(original_screen, 240, 160, 230, 40);
 
     current_menu = new_menu;
+
     current_option = new_menu->options;
     current_option_num = 0;
     if(current_menu->init_function)
@@ -1444,6 +1342,9 @@
   SDL_PauseAudio(1);
   SDL_UnlockMutex(sound_mutex);
 
+  clock_speed_number = (game_config_clock_speed / 33) - 1;
+  set_cpu_clock(222);
+
   if(gamepak_filename[0] == 0)
   {
     first_load = 1;
@@ -1451,6 +1352,12 @@
     print_string_ext(msg[MSG_NON_LOAD_GAME], 0xFFFF, 0x0000, 60, 75,original_screen, 240, 0);
   }
 
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
+    gamepak_file_large = -2;
+  }
+
   choose_menu(&main_menu);
 
   for(i = 0; i < MAX_CHEATS; i++)
@@ -1478,14 +1385,14 @@
 
     for(i = 0; i < current_menu->num_options; i++, display_option++)
     {
-      if(display_option->option_type & NUMBER_SELECTION_OPTION)
+      if(display_option->option_type & NUMBER_SELECTION_TYPE)
       {
         sprintf(line_buffer, display_option->display_string,
          *(display_option->current_option));
       }
       else
 
-      if(display_option->option_type & STRING_SELECTION_OPTION)
+      if(display_option->option_type & STRING_SELECTION_TYPE)
       {
         sprintf(line_buffer, display_option->display_string,
          ((u32 *)display_option->options)[*(display_option->current_option)]);
@@ -1507,8 +1414,7 @@
       }
     }
 
-    print_string(current_option->help_string, COLOR_HELP_TEXT,
-     COLOR_BG, 30, 210);
+    print_string(current_option->help_string, COLOR_HELP_TEXT, COLOR_BG, 30, 210);
 
     flip_screen();
 
@@ -1535,8 +1441,8 @@
         break;
 
       case CURSOR_RIGHT:
-        if(current_option->option_type & (NUMBER_SELECTION_OPTION |
-         STRING_SELECTION_OPTION))
+        if(current_option->option_type & (NUMBER_SELECTION_TYPE |
+         STRING_SELECTION_TYPE))
         {
           *(current_option->current_option) =
            (*current_option->current_option + 1) %
@@ -1548,8 +1454,8 @@
         break;
 
       case CURSOR_LEFT:
-        if(current_option->option_type & (NUMBER_SELECTION_OPTION |
-         STRING_SELECTION_OPTION))
+        if(current_option->option_type & (NUMBER_SELECTION_TYPE |
+         STRING_SELECTION_TYPE))
         {
           u32 current_option_val = *(current_option->current_option);
 
@@ -1573,10 +1479,10 @@
         break;
 
       case CURSOR_SELECT:
-        if(current_option->option_type & ACTION_OPTION)
+        if(current_option->option_type & ACTION_TYPE)
           current_option->action_function();
 
-        if(current_option->option_type & SUBMENU_OPTION)
+        if(current_option->option_type & SUBMENU_TYPE)
           choose_menu(current_option->sub_menu);
         break;
 
@@ -1586,16 +1492,38 @@
     }
   }
 
-// menu�I�����̏���
+// menu終了時の処理
+
+  /* スリープから復帰直後にはファイルを開けない。*/
+  /* タイミングによって、開ける様になるまでの時間にばらつきがある。 */
+  /* すぐにファイル開けるようなら即復帰させたいので、ウェイトは短め */
+  /* でリトライさせる。 */
+  if(gamepak_file_large == -2)
+  {
+    for(i = 0; i < 5; i++)
+    {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    printf("Failed to load gemepak.\n");
+    delay_us(3000000);
+    quit();
+
+    success_open_gamepak:;
+  }
 
   while(sceCtrlPeekBufferPositive(&ctrl_data, 1), ctrl_data.Buttons != 0);
 
   set_gba_resolution(screen_scale);
   video_resolution_small();
 
-  game_config_clock_speed = (clock_speed_number + 1) * 33;
-
-  scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+  game_config_clock_speed = (clock_speed_number + 1) * 333 / 10;
+  set_cpu_clock(game_config_clock_speed);
 
   SDL_PauseAudio(0);
 
@@ -1627,10 +1555,10 @@
         {
           case 0:
             if(opendir(current_str) != NULL)
-              strcpy(default_rom_dir,current_str);
+              strcpy(DEFAULT_ROM_DIR,current_str);
             else
             {
-              *default_rom_dir = (char)NULL;
+              *DEFAULT_ROM_DIR = (char)NULL;
               printf("not open rom dir : %s\n",current_str);
               delay_us(500000);
             }
@@ -1639,10 +1567,10 @@
 
           case 1:
             if(opendir(current_str) != NULL)
-              strcpy(default_save_dir,current_str);
+              strcpy(DEFAULT_SAVE_DIR,current_str);
             else
             {
-              *default_save_dir = (char)NULL;
+              *DEFAULT_SAVE_DIR = (char)NULL;
               printf("not open save dir : %s\n",current_str);
               delay_us(500000);
             }
@@ -1651,10 +1579,10 @@
 
           case 2:
             if(opendir(current_str) != NULL)
-              strcpy(default_cfg_dir,current_str);
+              strcpy(DEFAULT_CFG_DIR,current_str);
             else
             {
-              *default_cfg_dir = (char)NULL;
+              *DEFAULT_CFG_DIR = (char)NULL;
               printf("not open cfg dir : %s\n",current_str);
               delay_us(500000);
             }
@@ -1663,10 +1591,10 @@
 
           case 3:
             if(opendir(current_str) != NULL)
-              strcpy(default_ss_dir,current_str);
+              strcpy(DEFAULT_SS_DIR,current_str);
             else
             {
-              *default_ss_dir = (char)NULL;
+              *DEFAULT_SS_DIR = (char)NULL;
               printf("not open screen shot dir : %s\n",current_str);
               delay_us(500000);
             }
@@ -1675,10 +1603,10 @@
 
           case 4:
             if(opendir(current_str) != NULL)
-              strcpy(default_cheat_dir,current_str);
+              strcpy(DEFAULT_CHEAT_DIR,current_str);
             else
             {
-              *default_cheat_dir = (char)NULL;
+              *DEFAULT_CHEAT_DIR = (char)NULL;
               printf("not open cheat dir : %s\n",current_str);
               delay_us(500000);
             }
@@ -1804,7 +1732,166 @@
   return -1;
 }
 
-u32 parse_line(char *current_line, char *current_str)
+u32 load_font()
+{
+    return fbm_init(font8,font16,1);
+}
+
+void get_savestate_filename_noshot(u32 slot, char *name_buffer)
+{
+  char savestate_ext[16];
+
+  sprintf(savestate_ext, "_%d.svs", (int)slot);
+  change_ext(gamepak_filename, name_buffer, savestate_ext);
+}
+
+/******************************************************************************
+ * ローカル関数の定義
+ ******************************************************************************/
+static s32 save_game_config_file()
+{
+  char game_config_filename[MAX_FILE];
+  char game_config_path[MAX_PATH];
+  u32 i;
+  FILE_ID game_config_file;
+
+  if(gamepak_filename[0] == 0) return -1;
+
+  change_ext(gamepak_filename, game_config_filename, ".cfg");
+
+  if (DEFAULT_CFG_DIR != NULL) {
+    sprintf(game_config_path, "%s/%s", DEFAULT_CFG_DIR, game_config_filename);
+  }
+  else
+  {
+    strcpy(game_config_path, game_config_filename);
+  }
+
+  FILE_OPEN(game_config_file, game_config_path, WRITE);
+  if(FILE_CHECK_VALID(game_config_file))
+  {
+    u32 file_options[4 + MAX_CHEATS];
+
+    file_options[0] = game_config_frameskip_type;
+    file_options[1] = game_config_frameskip_value;
+    file_options[2] = game_config_random_skip;
+    file_options[3] = game_config_clock_speed;
+
+    for(i = 0; i < MAX_CHEATS; i++)
+    {
+      file_options[4 + i] = game_config_cheats[i].cheat_active;
+    }
+
+    FILE_WRITE_ARRAY(game_config_file, file_options);
+    FILE_CLOSE(game_config_file);
+
+    return 0;
+  }
+
+  return -1;
+}
+
+static s32 save_config_file()
+{
+  char config_path[512];
+  FILE_ID config_file;
+
+  sprintf(config_path, "%s/%s", main_path, GPSP_CONFIG_FILENAME);
+
+  FILE_OPEN(config_file, config_path, WRITE);
+
+  save_game_config_file();
+
+  if(FILE_CHECK_VALID(config_file))
+  {
+    u32 file_options[23];
+    u32 i;
+
+    file_options[0] = screen_scale;
+    file_options[1] = screen_filter;
+    file_options[2] = global_enable_audio;
+    file_options[3] = audio_buffer_size_number;
+    file_options[4] = update_backup_flag;
+    file_options[5] = global_enable_analog;
+    file_options[6] = analog_sensitivity_level;
+
+    for(i = 0; i < 16; i++)
+    {
+      file_options[7 + i] = gamepad_config_map[i];
+    }
+
+    FILE_WRITE_ARRAY(config_file, file_options);
+    FILE_CLOSE(config_file);
+
+    return 0;
+  }
+
+  return -1;
+}
+
+static void get_savestate_snapshot(char *savestate_filename)
+{
+  u16 snapshot_buffer[240 * 160];
+  char savestate_timestamp_string[80];
+  char savestate_path[1024];
+  FILE_ID savestate_file;
+
+  if (DEFAULT_SAVE_DIR != NULL) {
+    sprintf(savestate_path, "%s/%s", DEFAULT_SAVE_DIR, savestate_filename);
+  }
+  else
+  {
+    strcpy(savestate_path, savestate_filename);
+  }
+
+  FILE_OPEN(savestate_file, savestate_path, READ);
+
+  if(FILE_CHECK_VALID(savestate_file))
+  {
+    u64 savestate_time_flat;
+    u64 local_time;
+//    u64 utc;
+//    u64 local;
+    int wday;
+    int time_diff;
+    pspTime current_time;
+    FILE_READ_ARRAY(savestate_file, snapshot_buffer);
+    FILE_READ_VARIABLE(savestate_file, savestate_time_flat);
+
+    FILE_CLOSE(savestate_file);
+
+    sceRtcConvertUtcToLocalTime(&savestate_time_flat, &local_time);
+
+    sceRtcSetTick(&current_time, &local_time);
+    wday = sceRtcGetDayOfWeek(current_time.year, current_time.month, current_time.day);
+    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_FMT_0, current_time.year, current_time.month, current_time.day,
+      wday, current_time.hour, current_time.minutes, current_time.seconds, 0);
+
+    savestate_timestamp_string[40] = 0;
+
+    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
+  }
+  else
+  {
+    memset(snapshot_buffer, 0, 240 * 160 * 2);
+    print_string_ext(msg[MSG_STATE_MENU_STATE_NONE], 0xFFFF, 0x0000, 15, 75, snapshot_buffer, 240, 0);
+    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_NONE_0, 0, 0, 0, 0, 0, 0, 0, 0);
+    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
+  }
+  blit_to_screen(snapshot_buffer, 240, 160, 230, 40);
+}
+
+static void get_savestate_filename(u32 slot, char *name_buffer)
+{
+  char savestate_ext[16];
+
+  sprintf(savestate_ext, "_%d.svs", (int)slot);
+  change_ext(gamepak_filename, name_buffer, savestate_ext);
+
+  get_savestate_snapshot(name_buffer);
+}
+
+static u32 parse_line(char *current_line, char *current_str)
 {
   char *line_ptr;
   char *line_ptr_new;
@@ -1842,12 +1929,7 @@
   return 0;
 }
 
-u32 load_font()
-{
-    return fbm_init(font8,font16,1);
-}
-
-void print_status()
+static void print_status()
 {
   char print_buffer_1[256];
   char print_buffer_2[256];
@@ -1864,24 +1946,23 @@
   sprintf(print_buffer_1, msg[MSG_MENU_BATTERY], scePowerGetBatteryLifePercent(), scePowerGetBatteryLifeTime());
   print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 0);
 
-//  sprintf(print_buffer_1, "TOTAL FREE:%04dkb  MAX FREE:%04dkb", sceKernelTotalFreeMemSize()/1024, sceKernelMaxFreeMemSize()/1024);
-//  print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 10);
-
   sprintf(print_buffer_1, "MAX ROM BUF: %02d MB", (int)(gamepak_ram_buffer_size/1024/1024));
   print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 10);
 }
 
-void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
+static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
 {
-  int id;
+//  int id;
   char *weekday_strings[] =
   {
     msg[MSG_WDAY_0], msg[MSG_WDAY_1], msg[MSG_WDAY_2], msg[MSG_WDAY_3],
     msg[MSG_WDAY_4], msg[MSG_WDAY_5], msg[MSG_WDAY_6], ""
   };
 
-  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
-  switch(id)
+  /* 表示更新の度にフラッシュから設定を読み込んでいるためメニューの動作が遅い。*/
+//  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
+//  switch(id)
+  switch(date_format)
   {
     case PSP_SYSTEMPARAM_DATE_FORMAT_YYYYMMDD:
       sprintf(buffer, msg[msg_id    ], year, mon, day, weekday_strings[wday], hour, min, sec, msec / 1000);
@@ -1895,7 +1976,7 @@
   }
 }
 
-void save_ss_bmp(u16 *image)
+static void save_ss_bmp(u16 *image)
 {
   static unsigned char header[] ={ 'B',  'M',  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
                                    0x00, 0x00,  240, 0x00, 0x00, 0x00,  160, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
@@ -1918,8 +1999,8 @@
   get_timestamp_string(timestamp, MSG_SS_FMT_0, current_time.year, current_time.month , current_time.day, 7,
     current_time.hour, current_time.minutes, current_time.seconds, current_time.microseconds);
 
-  if (default_ss_dir != NULL) {
-    sprintf(save_ss_path, "%s/%s%s.bmp", default_ss_dir, ss_filename, timestamp);
+  if (DEFAULT_SS_DIR != NULL) {
+    sprintf(save_ss_path, "%s/%s%s.bmp", DEFAULT_SS_DIR, ss_filename, timestamp);
   }
   else
   {
@@ -1949,3 +2030,87 @@
     fclose( ss );
 
 }
+
+#ifdef progress
+/******************************************************************************
+  プログレスバー表示
+******************************************************************************/
+
+static int progress_total;
+static int progress_current;
+static char progress_message[64];
+
+/*--------------------------------------------------------
+  プログレスバー初期化
+--------------------------------------------------------*/
+
+void init_progress(int total, const char *text)
+{
+  progress_current = 0;
+  progress_total   = total;
+  strcpy(progress_message, text);
+
+  draw_dialog(240-158, 136-26, 240+158, 136+26);
+  boxfill(240-151, 138+2, 240+151, 138+14, 0, 0, 0);
+
+  uifont_print_shadow_center(118, 255,255,255, text);
+  draw_battery_status(1);
+
+  video_flip_screen(1);
+}
+
+
+/*--------------------------------------------------------
+  プログレスバー更新
+--------------------------------------------------------*/
+
+void update_progress(void)
+{
+  int width = (++progress_current * 100 / progress_total) * 3;
+
+  show_background();
+
+  draw_dialog(240-158, 136-26, 240+158, 136+26);
+  boxfill(240-151, 138+2, 240+151, 138+14, 0, 0, 0);
+
+  uifont_print_shadow_center(118, 255,255,255, progress_message);
+  draw_battery_status(1);
+
+  boxfill(240-150, 138+3, 240-150+width-1, 138+13, 128, 128, 128);
+
+  video_flip_screen(1);
+}
+
+
+/*--------------------------------------------------------
+  プログレスバー結果表示
+--------------------------------------------------------*/
+
+void show_progress(const char *text)
+{
+  show_background();
+
+  draw_dialog(240-158, 136-26, 240+158, 136+26);
+  boxfill(240-151, 138+2, 240+151, 138+14, 0, 0, 0);
+
+  uifont_print_shadow_center(118, 255,255,255, text);
+  draw_battery_status(1);
+
+  if (progress_current)
+  {
+    int width = (progress_current * 100 / progress_total) * 3;
+    boxfill(240-150, 138+3, 240-150+width-1, 138+13, 128, 128, 128);
+  }
+
+  video_flip_screen(1);
+
+  sceKernelDelayThread(1000000);
+}
+#endif
+
+void _flush_cache()
+{
+//    sceKernelDcacheWritebackAll();
+    invalidate_all_cache();
+}
+
diff -ru 30_orig/gui.h 30_new/gui.h
--- 30_orig/gui.h	2007-08-26 00:49:55.093782600 +0900
+++ 30_new/gui.h	2007-08-05 23:04:12.000000000 +0900
@@ -18,40 +18,36 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/******************************************************************************
+ * gui.h
+ * gui周りの処理
+ ******************************************************************************/
 #ifndef GUI_H
 #define GUI_H
 
-#define GPSP_CONFIG_FILENAME "gpsp.cfg"
-
+/******************************************************************************
+ * グローバル変数の宣言
+ ******************************************************************************/
+extern u32 SAVESTATE_SLOT;
+extern char DEFAULT_ROM_DIR[512];
+extern char DEFAULT_SAVE_DIR[512];
+extern char DEFAULT_CFG_DIR[512];
+extern char DEFAULT_SS_DIR[512];
+extern char DEFAULT_CHEAT_DIR[512];
+
+/******************************************************************************
+ * グローバル関数の宣言
+ ******************************************************************************/
 s32 load_file(char **wildcards, char *result, char *default_dir_name);
-u32 adjust_frameskip(u32 button_id);
 s32 load_game_config_file();
 s32 load_config_file();
-s32 save_game_config_file();
-s32 save_config_file();
 u32 menu(u16 *original_screen);
 
 u32 load_dircfg(char *file_name);
 u32 load_fontcfg(char *file_name);
 u32 load_msgcfg(char *file_name);
-u32 parse_line(char *current_line, char *current_str);
 u32 load_font();
-
-void print_status();
-void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec);
-void save_ss_bmp(u16 *image);
-
-extern u32 savestate_slot;
-
 void get_savestate_filename_noshot(u32 slot, char *name_buffer);
-void get_savestate_filename(u32 slot, char *name_buffer);
-void get_savestate_snapshot(char *savestate_filename);
-
-extern char default_rom_dir[512];
-extern char default_save_dir[512];
-extern char default_cfg_dir[512];
-extern char default_ss_dir[512];
-extern char default_cheat_dir[512];
 
 #endif
 
diff -ru 30_orig/input.c 30_new/input.c
--- 30_orig/input.c	2007-08-26 00:49:54.912782600 +0900
+++ 30_new/input.c	2007-08-06 23:46:08.000000000 +0900
@@ -104,19 +104,24 @@
     quit();
 
   sceCtrlPeekBufferPositive(&ctrl_data, 1);
-  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
-  if(ctrl_data.Lx < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_LEFT;
+  /* HOLD時アナログPADも動作しないようにする */
+  if(!(ctrl_data.Buttons & PSP_CTRL_HOLD))
+  {
+    if(ctrl_data.Lx < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_LEFT;
 
-  if(ctrl_data.Lx > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_RIGHT;
+    if(ctrl_data.Lx > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_RIGHT;
 
-  if(ctrl_data.Ly < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_UP;
+    if(ctrl_data.Ly < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_UP;
 
-  if(ctrl_data.Ly > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_DOWN;
+    if(ctrl_data.Ly > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_DOWN;
+  }
+
+  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
   new_buttons = (last_buttons ^ ctrl_data.Buttons) & ctrl_data.Buttons;
   last_buttons = ctrl_data.Buttons;
@@ -260,7 +265,8 @@
 
   buttons = ctrl_data.Buttons;
 
-  if(global_enable_analog)
+  /* HOLD時アナログPADも動作しないようにする */
+  if((global_enable_analog) && !(ctrl_data.Buttons & PSP_CTRL_HOLD))
   {
     if(ctrl_data.Lx < analog_sensitivity)
       buttons |= PSP_CTRL_ANALOG_LEFT;
@@ -297,7 +303,7 @@
       case BUTTON_ID_LOADSTATE:
       {
         char current_savestate_filename[512];
-        get_savestate_filename_noshot(savestate_slot, current_savestate_filename);
+        get_savestate_filename_noshot(SAVESTATE_SLOT, current_savestate_filename);
         load_state(current_savestate_filename);
         return 1;
       }
@@ -306,7 +312,7 @@
       {
         char current_savestate_filename[512];
         u16 *current_screen = copy_screen();
-        get_savestate_filename_noshot(savestate_slot,
+        get_savestate_filename_noshot(SAVESTATE_SLOT,
          current_savestate_filename);
         save_state(current_savestate_filename, current_screen);
         free(current_screen);
diff -ru 30_orig/main.c 30_new/main.c
--- 30_orig/main.c	2007-08-26 00:49:55.008782600 +0900
+++ 30_new/main.c	2007-08-06 23:47:24.000000000 +0900
@@ -19,32 +19,25 @@
  */
 
 /******************************************************************************
- * �w�b�_�t�@�C���̓Ǎ���
+ * ヘッダファイルの読込み
  ******************************************************************************/
 #include "common.h"
 
-// SDL��g�p���Ă���̕s�K�v
-//PSP_MODULE_INFO("gpSP", 0x1000, 0, 9);
+// 改造SDLを使用し、カーネルモードに設定
+// PSP_MODULE_INFO("gpSP", 0x1000, VERSION_MAJOR, VERSION_MINOR);
 //PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_USER | PSP_THREAD_ATTR_VFPU);
+// PSP_MAIN_THREAD_ATTR(0);
+
 
 /******************************************************************************
- * �ϐ��̒�`
+ * 変数の定義
  ******************************************************************************/
 
-TIMER_TYPE timer[4];
-
-// �t���[���X�L�b�v�̎��
-u32 game_config_frameskip_type = auto_frameskip;
-
-// �t���[���X�L�b�v��
-u32 game_config_frameskip_value = 4;
-
-// �����_���X�L�b�v
-u32 game_config_random_skip = 0;
-
-// �N���b�N��
-u32 game_config_clock_speed = 333;
-
+TIMER_TYPE timer[4];                              // タイマー
+u32 game_config_frameskip_type = auto_frameskip;  // フレームスキップの種類
+u32 game_config_frameskip_value = 9;              // フレームスキップ数
+u32 game_config_random_skip = 0;                  // ランダムスキップのon/off
+u32 game_config_clock_speed = 333;                // クロック数
 
 u32 global_cycles_per_instruction = 1;
 u64 frame_count_initial_timestamp = 0;
@@ -82,7 +75,8 @@
 char main_path[MAX_PATH];
 
 u32 quit_flag;
-u32 power_flag;
+// u32 power_flag;
+u8 sleep_flag;
 
 char *lang[9] =
   { "japanese",   // 0
@@ -97,13 +91,14 @@
     };
 
 int lang_num;
+int date_format;
 
 u32 prescale_table[] = { 0, 6, 8, 10 };
 
 char *file_ext[] = { ".gba", ".bin", ".zip", NULL };
 
 /******************************************************************************
- * �}�N�����̒�`
+ * マクロ等の定義
  ******************************************************************************/
 
 #define CHECK_COUNT(count_var)                                                \
@@ -121,7 +116,7 @@
     {                                                                         \
       timer[timer_number].count -= execute_cycles;                            \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale);  \
     }                                                                         \
                                                                               \
     if(timer[timer_number].count <= 0)                                        \
@@ -134,9 +129,12 @@
       {                                                                       \
         timer[timer_number + 1].count--;                                      \
         io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
-        0xFFFF   - (timer[timer_number + 1].count);                          \
+         0xFFFF   - (timer[timer_number + 1].count);                          \
       }                                                                       \
                                                                               \
+      u32 timer_reload                                                        \
+           = timer[timer_number].reload << timer[timer_number].prescale;      \
+                                                                              \
       if(timer_number < 2)                                                    \
       {                                                                       \
         if(timer[timer_number].direct_sound_channels & 0x01)                  \
@@ -144,22 +142,32 @@
                                                                               \
         if(timer[timer_number].direct_sound_channels & 0x02)                  \
           sound_timer(timer[timer_number].frequency_step, 1);                 \
+                                                                              \
+        /* 新しいリロード値は、オーバーフロー後カウンタの値に適用される。*/   \
+        /* リロード値とカウンター値にずれが生じるがどちらを使えばいい  */     \
+        /* のだろうか？ */                                                    \
+        if(timer[timer_number].reload_update)                                 \
+        {                                                                     \
+          sound_update_frequency_step(timer_number);                          \
+          timer[timer_number].reload_update = 0;                              \
+        }                                                                     \
       }                                                                       \
                                                                               \
-      timer[timer_number].count +=                                            \
-       (timer[timer_number].reload << timer[timer_number].prescale);          \
+      timer[timer_number].count += timer_reload;                              \
+                                                                              \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale);  \
     }                                                                         \
   }                                                                           \
 
-// ���[�J���֐��̐錾
+// ローカル関数の宣言
 void vblank_interrupt_handler(u32 sub, u32 *parg);
 void init_main();
 int main(int argc, char *argv[]);
 void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str);
 void trigger_ext_event();
-u32 check_power();
+// u32 check_power();
+void loop_sleep();
 int exit_callback(int arg1, int arg2, void *common);
 int power_callback(int unknown, int powerInfo, void *common);
 int CallbackThread(SceSize args, void *argp);
@@ -167,6 +175,11 @@
 
 
 
+void set_cpu_clock(u32 clock)
+{
+  scePowerSetClockFrequency(clock, clock, clock / 2);
+}
+
 
 void init_main()
 {
@@ -199,7 +212,7 @@
   flush_translation_cache_bios();
 }
 
-// SDL.h�ɂ��ASDL_main�Ƃ��Ē�`�����
+// SDL.hにより、SDL_mainとして定義される
 int main(int argc, char *argv[])
 {
 //  u32 i;
@@ -210,17 +223,21 @@
   char filename[512];
 
   quit_flag = 0;
-  power_flag = 0;
+//  power_flag = 0;
+  sleep_flag = 0;
   SetupCallbacks();
 
   sceKernelRegisterSubIntrHandler(PSP_VBLANK_INT, 0, vblank_interrupt_handler, NULL);
   sceKernelEnableSubIntr(PSP_VBLANK_INT, 0);
+
+  // デバッグ出力ファイルのオープン
   dbg_file = fopen(DBG_FILE_NAME, "awb");
 
   // Copy the directory path of the executable into main_path
   getcwd(main_path, 512);
 
   sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_LANGUAGE, &lang_num);
+  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&date_format);
 
   if (load_dircfg("settings/dir.cfg") != 0)
   {
@@ -247,6 +264,13 @@
     error_msg("font init Error!!");
     quit();
   }
+/* 起動できないので一時削除
+  // adhoc用モジュールのロード
+  if(pspSdkLoadAdhocModules() != 0)
+  {
+    error_msg("not use wlan!!");
+  } */
+//  u32 test = adhocInit("test");
 
   init_gamepak_buffer();
 
@@ -254,7 +278,7 @@
 
   gamepak_filename[0] = 0;
 
-  delay_us(1500000);
+//  delay_us(1500000);
 
   init_main();
   init_sound();
@@ -264,7 +288,9 @@
 
   video_resolution_large();
 
-  if(load_bios("gba_bios.bin") == -1)
+  u32 bios_ret = load_bios("gba_bios.bin");
+
+  if(bios_ret == -1) // 読込めない場合
   {
     print_string(msg[MSG_ERR_BIOS_1], 0xFFFF, 0x0000, 0, 0);
     print_string(msg[MSG_ERR_BIOS_2], 0xFFFF, 0x0000, 0, 60);
@@ -272,7 +298,7 @@
     quit();
   }
 
-  if(load_bios("gba_bios.bin") == -2)
+  if(bios_ret == -2) // MD5が違う場合
   {
     print_string(msg[MSG_ERR_BIOS_MD5], 0xFFFF, 0x0000, 0, 0);
     delay_us(5000000);
@@ -291,10 +317,11 @@
 
     init_cpu();
     init_memory();
+    reset_sound();
   }
   else
   {
-    if(load_file(file_ext, load_filename, default_rom_dir) == -1)
+    if(load_file(file_ext, load_filename, DEFAULT_ROM_DIR) == -1)
     {
       menu(copy_screen());
     }
@@ -317,6 +344,9 @@
   }
 
   last_frame = 0;
+  /* 起動時のファイルリストからromをロードした場合、メニュー終了時の */
+  /* クロック変更が適用されないので、ここでクロック変更。 */
+  set_cpu_clock(game_config_clock_speed);
 
   // We'll never actually return from here.
 
@@ -370,7 +400,7 @@
   no_alpha = 0;
   synchronize_flag = 0;
 
-  get_savestate_filename_noshot(savestate_slot, current_savestate_filename);
+  get_savestate_filename_noshot(SAVESTATE_SLOT, current_savestate_filename);
   load_state(current_savestate_filename);
 
   switch(event_number)
@@ -446,6 +476,7 @@
   event_number++;
 }
 
+/*
 u32 check_power()
   {
     if (power_flag == 0) return 0;
@@ -457,6 +488,46 @@
     FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
     return ret_val;
   }
+*/
+/* スリープ時にファイルを閉じて、復帰後開き直す。 */
+/* 再び開けるようになるまでには、タイミングによってばらつきがある。*/
+
+void loop_sleep()
+{
+  SDL_PauseAudio(1);
+
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
+
+    while(sleep_flag)
+      delay_us(500000);
+
+    u8 i;
+    for(i = 0; i < 5; i++)
+    {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    printf("Failed to load gemepak.\n");
+    delay_us(3000000);
+    quit_flag = 1;
+
+    success_open_gamepak:;
+  }
+  else
+  {
+    while(sleep_flag)
+      delay_us(500000);
+  }
+
+  SDL_PauseAudio(0);
+}
 
 u32 update_gba()
 {
@@ -549,12 +620,15 @@
           dispstat &= ~0x01;
 //          frame_ticks++;
 
+          if(sleep_flag)
+            loop_sleep();
+
           if (update_input())
             continue;
-
+/*
           if (check_power())
             continue;
-
+*/
           if (quit_flag == 1)
             quit();
 
@@ -753,7 +827,7 @@
 
   fclose(dbg_file);
 
-  scePowerSetClockFrequency(222, 222, 111);
+  set_cpu_clock(222);
   sceKernelExitGame();
 }
 
@@ -819,7 +893,15 @@
 
 int power_callback(int unknown, int powerInfo, void *common)
 {
-  if (powerInfo & PSP_POWER_CB_SUSPENDING) power_flag = 1;
+  if(powerInfo & PSP_POWER_CB_SUSPENDING)
+  {
+    sleep_flag = 1;
+  }
+  else
+  if(powerInfo & PSP_POWER_CB_RESUME_COMPLETE)
+  {
+    sleep_flag = 0;
+  }
   return 0;
 }
 
@@ -827,11 +909,11 @@
 {
   int cbid, power_callback_id;
 
-  // �I�����̃R�[���o�b�N 
+  // 終了周りのコールバック 
   cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
   sceKernelRegisterExitCallback(cbid);
 
-  // �d�����̃R�[���o�b�N 
+  // 電源周りのコールバック 
   power_callback_id = sceKernelCreateCallback("Power Callback", power_callback, NULL); 
   scePowerRegisterCallback(0, power_callback_id);
 
diff -ru 30_orig/main.h 30_new/main.h
--- 30_orig/main.h	2007-08-26 00:49:55.098782600 +0900
+++ 30_new/main.h	2007-08-06 23:46:36.000000000 +0900
@@ -46,6 +46,7 @@
 {
   s32 count;
   u32 reload;
+  u8 reload_update;
   u32 prescale;
   u32 stop_cpu_ticks;
   FIXED16_16 frequency_step;
@@ -93,6 +94,9 @@
 extern u32 num_skipped_frames;
 extern u64 frame_count_initial_timestamp;
 
+extern int date_format;
+void set_cpu_clock(u32 clock);
+
 u32 update_gba();
 void reset_gba();
 void synchronize();
@@ -110,12 +114,7 @@
 
 #define count_timer(timer_number)                                             \
   timer[timer_number].reload = 0x10000 - value;                               \
-  if(timer_number < 2)                                                        \
-  {                                                                           \
-    u32 timer_reload =                                                        \
-     timer[timer_number].reload << timer[timer_number].prescale;              \
-    sound_update_frequency_step(timer_number);                                \
-  }                                                                           \
+  timer[timer_number].reload_update = 1                                       \
 
 #define adjust_sound_buffer(timer_number, channel)                            \
   if(timer[timer_number].direct_sound_channels & (0x01 << channel))           \
@@ -154,7 +153,7 @@
       {                                                                       \
         u32 buffer_adjust =                                                   \
          (u32)(((float)(cpu_ticks - timer[timer_number].stop_cpu_ticks) *     \
-         SOUND_FREQUENCY) / 16777216.0) * 2;                                  \
+         sound_frequency) / 16777216.0) * 2;                                  \
                                                                               \
         sound_update_frequency_step(timer_number);                            \
         adjust_sound_buffer(timer_number, 0);                                 \
diff -ru 30_orig/memory.h 30_new/memory.h
--- 30_orig/memory.h	2007-08-26 00:49:54.994782600 +0900
+++ 30_new/memory.h	2007-08-06 23:46:28.000000000 +0900
@@ -140,7 +140,7 @@
   REG_HALTCNT = 0x180
 } HARDWARE_REGISTER;
 
-// �O���[�o���ϐ��錾
+// グローバル変数宣言
 
 extern char gamepak_title[13];
 extern char gamepak_code[5];
@@ -172,7 +172,7 @@
 
 extern FILE_TAG_TYPE gamepak_file_large;
 
-// �֐��錾
+// 関数宣言
 
 extern u8 read_memory8(u32 address);
 extern u32 read_memory16(u32 address);
@@ -185,7 +185,7 @@
 extern CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma);
 extern u8 *memory_region(u32 address, u32 *memory_limit);
 extern s32 load_bios(char *name);
-extern u32 load_gamepak(char *name);
+extern s32 load_gamepak(char *name);
 extern u8 *load_gamepak_page(u32 physical_index);
 extern u32 load_backup(char *name);
 extern void init_memory();
Only in 30_new/: memory_new.c
diff -ru 30_orig/mips_emit.h 30_new/mips_emit.h
--- 30_orig/mips_emit.h	2007-08-26 00:49:55.119782600 +0900
+++ 30_new/mips_emit.h	2007-08-06 23:45:02.000000000 +0900
@@ -821,12 +821,12 @@
 
 #define generate_shift_reg_lsr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_lsr_flags_reg)                    \
 
 #define generate_shift_reg_asr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_asr_flags_reg)                    \
 
 #define generate_shift_reg_ror_flags(_rm, _rs)                                \
@@ -949,7 +949,7 @@
   u32 _address = (u32)(address);                                              \
   u32 _address_hi = (_address + 0x8000) >> 16;                                \
   generate_load_imm(ireg, address);                                           \
-  mips_emit_lui(ireg, _address_hi >> 16)                                      \
+  mips_emit_lui(ireg, _address_hi >> 16);                                     \
   generate_load_memory_##type(ireg, _address - (_address_hi << 16));          \
 }                                                                             \
 
@@ -1410,7 +1410,8 @@
 
 #define generate_op_adcs_reg(_rd, _rn, _rm)                                   \
   mips_emit_addu(reg_temp, _rm, reg_c_cache);                                 \
-  generate_add_flags_prologue(_rn, _rm);                                      \
+/*  generate_add_flags_prologue(_rn, _rm); */                                 \
+  generate_add_flags_prologue(_rn, reg_temp);                                 \
   mips_emit_addu(_rd, _rn, reg_temp);                                         \
   generate_add_flags_epilogue(_rd)                                            \
 
@@ -1537,20 +1538,54 @@
   arm_generate_op_imm(name, load_op)                                          \
 
 
+/* 1S+x+y */
+/* x=1I cycles if Op2 shifted-by-register. y=1S+1N cycles if Rd=R15. */
+#define cycle_arm_data_proc_reg()                                             \
+  cycle_count++;                                                              \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_reg_flags()                                       \
+  cycle_arm_data_proc_reg()                                                   \
+
+#define cycle_arm_data_proc_imm()                                             \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_imm_flags()                                       \
+  cycle_arm_data_proc_imm()                                                   \
+
+/* 1S+x */
+#define cycle_arm_data_proc_test_reg()                                        \
+  cycle_count++                                                               \
+
+#define cycle_arm_data_proc_test_reg_flags()                                  \
+  cycle_arm_data_proc_test_reg()                                              \
+
+#define cycle_arm_data_proc_test_imm()                                        \
+
+#define cycle_arm_data_proc_test_imm_flags()                                  \
+
+/* AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, ORR, BIC  1S+x+y */
 #define arm_data_proc(name, type, flags_op)                                   \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
+/* TST, TEQ, CMP, CMN  1S+x */
 #define arm_data_proc_test(name, type)                                        \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_test_##type();                                          \
 }                                                                             \
 
+/* MOV, MVN  1S+x+y */
 #define arm_data_proc_unary(name, type, flags_op)                             \
 {                                                                             \
   arm_generate_op_##type(name, no);                                           \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
@@ -1566,9 +1601,36 @@
   mips_emit_mflo(reg_temp);                                                   \
   mips_emit_addu(arm_to_mips_reg[rd], reg_temp, arm_to_mips_reg[rn])          \
 
+u32 cycle_multiply(_rs)
+{
+  u32 mult_rs = arm_to_mips_reg[_rs];
+  if(((s32)mult_rs) < 0)
+    mult_rs = ~mult_rs;
+
+  if((mult_rs & 0xFFFFFF00) == 0)  /* m=1 for Bit 31-8 */
+    return 1;
+  else
+  if((mult_rs & 0xFFFF0000) == 0)  /* m=2 for Bit 31-16 */
+    return 2;
+  else
+  if((mult_rs & 0xFF000000) == 0)  /* m=3 for Bit 31-24 */
+    return 3;
+  else                             /* m=4 otherwise */
+    return 4;
+}
+
+/* 1S+mI */
+#define cycle_arm_multiply_add_no()                                           \
+  cycle_count += cycle_multiply(rs)                                           \
+
+/* 1S+mI+1I */
+#define cycle_arm_multiply_add_yes()                                          \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
 #define arm_multiply(add_op, flags)                                           \
 {                                                                             \
   arm_decode_multiply();                                                      \
+  cycle_arm_multiply_add_##add_op();                                          \
   mips_emit_multu(arm_to_mips_reg[rm], arm_to_mips_reg[rs]);                  \
   arm_multiply_add_##add_op();                                                \
   arm_multiply_flags_##flags(arm_to_mips_reg[rd]);                            \
@@ -1590,9 +1652,18 @@
 #define arm_multiply_long_add_no(name)                                        \
   generate_multiply_##name()                                                  \
 
+/* 1S+mI+1I */
+#define cycle_arm_multiply_long_add_no()                                      \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
+/* 1S+mI+2I */
+#define cycle_arm_multiply_long_add_yes()                                     \
+  cycle_count += 2 + cycle_multiply(rs)                                       \
+
 #define arm_multiply_long(name, add_op, flags)                                \
 {                                                                             \
   arm_decode_multiply_long();                                                 \
+  cycle_arm_multiply_long_add_##add_op();                                     \
   arm_multiply_long_add_##add_op(name);                                       \
   mips_emit_mflo(arm_to_mips_reg[rdlo]);                                      \
   mips_emit_mfhi(arm_to_mips_reg[rdhi]);                                      \
@@ -1642,15 +1713,50 @@
   arm_psr_##transfer_type(op_type, psr_reg);                                  \
 }                                                                             \
 
+/* LDR: 1S+1N+1I. LDR PC: 2S+2N+1I. STR: 2N. */
+#define cycle_arm_access_memory_load_u32()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_u16()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_s16()                                    \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_u8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_s8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_store_u32()                                   \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_u16()                                   \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_s16()                                   \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_u8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_s8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
 #define arm_access_memory_load(mem_type)                                      \
-  cycle_count += 2;                                                           \
+  cycle_arm_access_memory_load_##mem_type();                                  \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 8));                                         \
   generate_store_reg(reg_rv, rd);                                             \
   check_store_reg_pc_no_flags(rd)                                             \
 
 #define arm_access_memory_store(mem_type)                                     \
-  cycle_count++;                                                              \
+  cycle_arm_access_memory_store_##mem_type();                                 \
   generate_load_pc(reg_a2, (pc + 4));                                         \
   generate_load_reg_pc(reg_a1, rd, 12);                                       \
   generate_function_call_swap_delay(execute_store_##mem_type)                 \
@@ -1737,11 +1843,22 @@
 #define sprint_yes(access_type, pre_op, post_op, wb)                          \
   printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
 
+/* LDM, nS+1N+1I. LDM PC, (n+1)S+2N+1I. STM (n-1)S+2N. */
 #define arm_block_memory_load()                                               \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define arm_block_memory_store()                                              \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_load_reg_pc(reg_a1, i, 8);                                         \
   generate_function_call_swap_delay(execute_aligned_store32)                  \
 
@@ -1754,10 +1871,13 @@
   generate_load_reg(reg_a1, i)                                                \
 
 #define arm_block_memory_adjust_pc_store()                                    \
+  cycle_count++;                                                              \
 
 #define arm_block_memory_adjust_pc_load()                                     \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_mov(reg_a0, reg_rv);                                             \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
@@ -1775,8 +1895,10 @@
 #define arm_block_memory_sp_adjust_pc_store()                                 \
 
 #define arm_block_memory_sp_adjust_pc_load()                                  \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
 
@@ -1847,7 +1969,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -1866,149 +1987,6 @@
   }                                                                           \
 }                                                                             \
 
-#define arm_block_writeback_no()
-
-#define arm_block_writeback_yes()                                             \
-  mips_emit_addu(arm_to_mips_reg[rn], reg_a2, reg_zero)                       \
-
-#define arm_block_address_preadjust_up_full(wb)                               \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   ((word_bit_count(reg_list)) * 4));                                         \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_up(wb)                                    \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn], 4);                            \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down_full(wb)                             \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -((word_bit_count(reg_list)) * 4));                                        \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down(wb)                                  \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -(((word_bit_count(reg_list)) * 4) - 4));                                  \
-  arm_block_writeback_##wb()
-
-#define arm_block_address_preadjust_no(wb)                                    \
-  mips_emit_addu(reg_a2, arm_to_mips_reg[rn], reg_zero)                       \
-
-#define arm_block_address_postadjust_no()                                     \
-
-#define arm_block_address_postadjust_up()                                     \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   ((word_bit_count(reg_list)) * 4))                                          \
-
-#define arm_block_address_postadjust_down()                                   \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   -((word_bit_count(reg_list)) * 4))                                         \
-
-#define sprint_no(access_type, pre_op, post_op, wb)                           \
-
-#define sprint_yes(access_type, pre_op, post_op, wb)                          \
-  printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
-
-#define arm_block_memory_load()                                               \
-  generate_function_call_swap_delay(execute_aligned_load32);                  \
-  generate_store_reg(reg_rv, i)                                               \
-
-#define arm_block_memory_store()                                              \
-  generate_load_reg_pc(reg_a1, i, 8);                                         \
-  generate_function_call_swap_delay(execute_aligned_store32)                  \
-
-#define arm_block_memory_final_load()                                         \
-  arm_block_memory_load()                                                     \
-
-#define arm_block_memory_final_store()                                        \
-  generate_load_pc(reg_a2, (pc + 4));                                         \
-  mips_emit_jal(mips_absolute_offset(execute_store_u32));                     \
-  generate_load_reg(reg_a1, i)                                                \
-
-#define arm_block_memory_adjust_pc_store()                                    \
-
-#define arm_block_memory_adjust_pc_load()                                     \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_mov(reg_a0, reg_rv);                                             \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define arm_block_memory_sp_load()                                            \
-  mips_emit_lw(arm_to_mips_reg[i], reg_a1, offset);                           \
-
-#define arm_block_memory_sp_store()                                           \
-{                                                                             \
-  u32 store_reg = i;                                                          \
-  check_load_reg_pc(arm_reg_a0, store_reg, 8);                                \
-  mips_emit_sw(arm_to_mips_reg[store_reg], reg_a1, offset);                   \
-}                                                                             \
-
-#define arm_block_memory_sp_adjust_pc_store()                                 \
-
-#define arm_block_memory_sp_adjust_pc_load()                                  \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define old_arm_block_memory(access_type, pre_op, post_op, wb, s_bit)         \
-{                                                                             \
-  arm_decode_block_trans();                                                   \
-  u32 i;                                                                      \
-  u32 offset = 0;                                                             \
-  u32 base_reg = arm_to_mips_reg[rn];                                         \
-                                                                              \
-  arm_block_address_preadjust_##pre_op(wb);                                   \
-  arm_block_address_postadjust_##post_op();                                   \
-                                                                              \
-  sprint_##s_bit(access_type, pre_op, post_op, wb);                           \
-                                                                              \
-  if((rn == REG_SP) && iwram_stack_optimize)                                  \
-  {                                                                           \
-    mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
-    generate_load_imm(reg_a0, ((u32)(iwram + 0x8000)));                       \
-    mips_emit_addu(reg_a1, reg_a1, reg_a0);                                   \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        arm_block_memory_sp_##access_type();                                  \
-        offset += 4;                                                          \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_sp_adjust_pc_##access_type();                            \
-  }                                                                           \
-  else                                                                        \
-  {                                                                           \
-    mips_emit_ins(reg_a2, reg_zero, 0, 2);                                    \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        mips_emit_addiu(reg_a0, reg_a2, offset);                              \
-        if(reg_list & ~((2 << i) - 1))                                        \
-        {                                                                     \
-          arm_block_memory_##access_type();                                   \
-          offset += 4;                                                        \
-        }                                                                     \
-        else                                                                  \
-        {                                                                     \
-          arm_block_memory_final_##access_type();                             \
-          break;                                                              \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_adjust_pc_##access_type();                               \
-  }                                                                           \
-}
-
-
 
 // This isn't really a correct implementation, may have to fix later.
 
@@ -2047,6 +2025,13 @@
   thumb_generate_op_##rn_type(name, _rd, _rs, _rn);                           \
 }                                                                             \
 
+#define thumb_data_proc_muls(type, rn_type, _rd, _rs, _rn)                    \
+{                                                                             \
+  thumb_decode_##type();                                                      \
+  cycle_count += cycle_multiply(_rs); /* 1S+mI */                             \
+  thumb_generate_op_##rn_type(muls, _rd, _rs, _rn);                           \
+}                                                                             \
+
 #define thumb_data_proc_test(type, name, rn_type, _rs, _rn)                   \
 {                                                                             \
   thumb_decode_##type();                                                      \
@@ -2068,6 +2053,8 @@
 #define thumb_data_proc_hi(name)                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   u32 dest_rd = rd;                                                           \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   check_load_reg_pc(arm_reg_a1, rd, 4);                                       \
@@ -2102,6 +2089,8 @@
 #define thumb_data_proc_mov_hi()                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   mips_emit_addu(arm_to_mips_reg[rd], arm_to_mips_reg[rs], reg_zero);         \
   check_store_reg_pc_thumb(rd);                                               \
@@ -2157,8 +2146,15 @@
   mips_emit_addu(arm_to_mips_reg[original_rd], reg_a0, reg_zero);             \
 }                                                                             \
 
+#define cycle_thumb_shift_shift()                                             \
+
+/* ALU operations LSL,LSR,ASR,ROR  1S+1I */
+#define cycle_thumb_shift_alu_op()                                            \
+  cycle_count++                                                               \
+
 #define thumb_shift(decode_type, op_type, value_type)                         \
 {                                                                             \
+  cycle_thumb_shift_##decode_type();                                          \
   thumb_decode_##decode_type();                                               \
   thumb_generate_shift_##value_type(op_type);                                 \
   generate_op_logic_flags(arm_to_mips_reg[rd]);                               \
@@ -2166,14 +2162,45 @@
 
 // Operation types: imm, mem_reg, mem_imm
 
+/* LDR 1S+1N+1I, STR 2N */
+#define cycle_thumb_access_memory_load_u32()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_u16()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_s16()                                  \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_u8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_s8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_store_u32()                                 \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_u16()                                 \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_s16()                                 \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_u8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_s8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
 #define thumb_access_memory_load(mem_type, reg_rd)                            \
-  cycle_count += 2;                                                           \
+  cycle_thumb_access_memory_load_##mem_type();                                \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 4));                                         \
   generate_store_reg(reg_rv, reg_rd)                                          \
 
 #define thumb_access_memory_store(mem_type, reg_rd)                           \
-  cycle_count++;                                                              \
+  cycle_thumb_access_memory_store_##mem_type();                               \
   generate_load_pc(reg_a2, (pc + 2));                                         \
   mips_emit_jal(mips_absolute_offset(execute_store_##mem_type));              \
   generate_load_reg(reg_a1, reg_rd)                                           \
@@ -2236,10 +2263,20 @@
 #define thumb_block_address_postadjust_push_lr(base_reg)                      \
 
 #define thumb_block_memory_load()                                             \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define thumb_block_memory_store()                                            \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   mips_emit_jal(mips_absolute_offset(execute_aligned_store32));               \
   generate_load_reg(reg_a1, i)                                                \
 
@@ -2300,8 +2337,17 @@
   generate_indirect_branch_cycle_update(thumb)                                \
 
 #define thumb_block_memory_sp_extra_push_lr()                                 \
+  cycle_count--;                                                              \
   mips_emit_sw(reg_r14, reg_a1, (bit_count[reg_list] * 4))                    \
 
+#define cycle_thumb_block_memory_load()                                       \
+  cycle_count++;                                                              \
+  if(reg_list & 0x8000)                                                       \
+    cycle_count += 2                                                          \
+
+#define cycle_thumb_block_memory_store()                                      \
+  cycle_count++                                                               \
+
 #define thumb_block_memory(access_type, pre_op, post_op, base_reg)            \
 {                                                                             \
   thumb_decode_rlist();                                                       \
@@ -2311,6 +2357,8 @@
   thumb_block_address_preadjust_##pre_op(base_reg);                           \
   thumb_block_address_postadjust_##post_op(base_reg);                         \
                                                                               \
+  cycle_thumb_block_memory_##access_type();                                   \
+                                                                              \
   if((base_reg == REG_SP) && iwram_stack_optimize)                            \
   {                                                                           \
     mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
@@ -2337,7 +2385,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -2354,12 +2401,11 @@
                                                                               \
     thumb_block_memory_extra_##post_op();                                     \
   }                                                                           \
-}
-
-
+}                                                                             \
 
 #define thumb_conditional_branch(condition)                                   \
 {                                                                             \
+  cycle_count +=2;                                                            \
   condition_check_type condition_check;                                       \
   generate_condition_##condition();                                           \
   generate_branch_no_cycle_update(                                            \
@@ -2370,35 +2416,42 @@
 }                                                                             \
 
 #define arm_conditional_block_header()                                        \
-  generate_condition();                                                       \
+  generate_condition()                                                        \
 
 #define arm_b()                                                               \
+  cycle_count += 2;                                                           \
   generate_branch()                                                           \
 
 #define arm_bl()                                                              \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, (pc + 4));                                        \
   generate_branch()                                                           \
 
 #define arm_bx()                                                              \
+  cycle_count += 2;                                                           \
   arm_decode_branchx();                                                       \
   generate_load_reg(reg_a0, rn);                                              \
   /*generate_load_pc(reg_a2, pc);*/                                           \
   generate_indirect_branch_dual()                                             \
 
 #define arm_swi()                                                             \
-  if (((opcode >> 16) &0xFF) >= 0x2B) break;                                  \
+  if(((opcode >> 16) & 0xFF) > 0x2A)                                          \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler((opcode >> 16) & 0xFF);                            \
   generate_load_pc(reg_a0, (pc + 4));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
-  generate_branch();                                                          \
+  generate_branch()                                                           \
 
 #define thumb_b()                                                             \
+  cycle_count += 2;                                                           \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
   block_exit_position++                                                       \
 
 #define thumb_bl()                                                            \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
@@ -2410,12 +2463,13 @@
   thumb_decode_branch();                                                      \
   generate_alu_imm(addiu, addu, reg_a0, reg_r14, (offset * 2));               \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
-  generate_indirect_branch_cycle_update(dual);                                \
+  generate_indirect_branch_cycle_update(thumb);                               \
   break;                                                                      \
 }                                                                             \
 
 #define thumb_bx()                                                            \
 {                                                                             \
+  cycle_count += 2;                                                           \
   thumb_decode_hireg_op();                                                    \
   generate_load_reg_pc(reg_a0, rs, 4);                                        \
   /*generate_load_pc(reg_a2, pc);*/                                           \
@@ -2423,14 +2477,16 @@
 }                                                                             \
 
 #define thumb_swi()                                                           \
-  if ((opcode & 0xFF) >= 0x2B) break;                                         \
+  if((opcode & 0xFF) > 0x2A)                                                  \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler(opcode & 0xFF);                                    \
   generate_load_pc(reg_a0, (pc + 2));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
-  block_exit_position++;                                                      \
+  block_exit_position++                                                       \
 
 u8 swi_hle_handle[256][2] =
 { /* use bios , emu bios */
@@ -2528,27 +2584,27 @@
     /* CpuFastSet */                                                          \
     if(swi_number == 0x0C)                                                    \
     {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
+      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                          \
+      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                          \
+      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                          \
       generate_function_call(bios_cpufastset);                                \
     }                                                                         \
                                                                               \
     /* BgAffineSet */                                                         \
     if(swi_number == 0x0E)                                                    \
     {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
+      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                          \
+      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                          \
+      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                          \
       generate_function_call(bios_bgaffineset);                               \
     }                                                                         \
                                                                               \
     /* ObjAffineSet */                                                        \
     if(swi_number == 0x0F)                                                    \
     {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
+      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                          \
+      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                          \
+      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                          \
       mips_emit_addu(mips_reg_a3, reg_r3, reg_zero);                          \
       generate_function_call(bios_objaffineset);                              \
     }                                                                         \
diff -ru 30_orig/mips_stub.S 30_new/mips_stub.S
--- 30_orig/mips_stub.S	2007-08-26 00:49:55.035782600 +0900
+++ 30_new/mips_stub.S	2007-08-06 23:46:18.000000000 +0900
@@ -132,10 +132,10 @@
 .endm
 
 .macro collapse_flags
-  lw $2, REG_CPSR($16)            # $2 = [$16 + REG_CPSR]		# load CPSR
-  andi $2, $2, 0xFF               # $2 = $2 and 0xFF			# isolate lower 8bits
-  collapse_flag 20, 31            # # store flags
-  collapse_flag 21, 30            #
+  lw $2, REG_CPSR($16)            # load CPSR
+  andi $2, $2, 0xFF               # isolate lower 8bits
+  collapse_flag 20, 31            # store flags
+  collapse_flag 21, 30
   collapse_flag 22, 29
   collapse_flag 23, 28
   sw $2, REG_CPSR($16)            # store CPSR
@@ -268,29 +268,24 @@
 .macro patch_handler ftable, force_open
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
   addiu $1, $0, (\force_open * 4)
 
 1:
   lui $2, %hi(\ftable)
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
-  srl $2, $2, 2                   # remove lower two bits
 
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -303,32 +298,25 @@
 .macro patch_handler_align ftable, alignment
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
-  addiu $1, $0, 4                 # force address to 0x1 (open)
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
+  addiu $1, $0, 4                 # force address to 0x1 (open) delay
 
 1:
   ins $1, $4, 6, \alignment       # place alignment bits into offset
   lui $2, %hi(\ftable)
-
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
 
-  srl $2, $2, 2                   # remove lower two bits
-
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -449,53 +437,51 @@
 
 
 .macro translate_region_vram_core
-  addiu $2, $2, -3                # see if it's 3
   ext $4, $4, 0, 17               # generate 17bit offset
-  bne $2, $0, 1f                  # if $2 != $0 then j 1:
-  lui $1, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $2, $0, 1f                 # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 1:
+  lui $1, %hi(vram)               # start loading vram address
   addu $2, $1, $4                 # $2 = (hi)vram + address
 .endm
 
 .macro translate_region_vram patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align16 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align32 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align16 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align32 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
@@ -506,7 +492,7 @@
   srl $2, $4, 15                  # $2 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $2 = memory_map_read[address >> 15]
-  lw $2, -32768($2)               # 
+  lw $2, -32768($2)
   bne $2, $0, 1f                  # if it's non-NULL continue
   andi $1, $4, \mask              # $1 = low 15bits of address (delay slot)
 
@@ -517,8 +503,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -565,8 +551,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -579,20 +565,18 @@
 
 .macro eeprom_load_a patch_handler
   region_check 0xD, \patch_handler
-
   sw $ra, REG_SAVE($16)           # save the return address (delay)
-  sw $6, REG_SAVE2($16)           # save a2
 
   save_registers                  # save the registers
 
   jal read_eeprom                 # get eeprom value in $2
-  nop
+  sw $6, REG_SAVE2($16)           # save a2 (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -634,7 +618,7 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
@@ -650,13 +634,13 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -690,13 +674,13 @@
 .macro open_load8_core
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x03               # isolate lower 3bits from address (delay)
+  andi $4, $4, 0x03               # in ARM mode, isolate lower 2bits from address
 
-  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory8                # get instruction at PC
@@ -718,13 +702,13 @@
 .macro open_load16_core
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x02               # isolate bit 1 from address (delay)
+  andi $4, $4, 0x02               # in ARM mode, isolate bit 1 from address
 
-  addu $4, $0, $0                 # zero out address bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  addu $4, $0, $0                 # in Thumb mode, zero out address bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory16               # get instruction at PC
@@ -757,14 +741,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:                                # join point
   restore_registers               # restore the other registers
@@ -775,7 +759,6 @@
 
 .macro open_load32_a patch_handler
   region_check_open \patch_handler
-
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
 
@@ -786,14 +769,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:
   restore_registers               # restore the other registers
@@ -820,7 +803,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -837,7 +820,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -961,9 +944,9 @@
 
 execute_load_bios_u8:
   region_check 0, patch_load_u8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -994,9 +977,18 @@
   load_u8 (iwram + 0x8000)
 
 execute_load_io_u8:
-  translate_region 4, patch_load_u8, io_registers, 0xFFF
+  region_check 4, patch_load_u8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u8 io_registers
 
+1:
+  open_load8_core
+  nop
+
 execute_load_palette_u8:
   translate_region 5, patch_load_u8, palette_ram, 0x3FF
   load_u8 palette_ram
@@ -1067,9 +1059,9 @@
 
 execute_load_bios_s8:
   region_check 0, patch_load_s8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1097,9 +1089,18 @@
   load_s8 (iwram + 0x8000)
 
 execute_load_io_s8:
-  translate_region 4, patch_load_s8, io_registers, 0xFFF
+  region_check 4, patch_load_s8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s8 io_registers
 
+1:
+  open_load8_core
+  seb $2, $2
+
 execute_load_palette_s8:
   translate_region 5, patch_load_s8, palette_ram, 0x3FF
   load_s8 palette_ram
@@ -1170,9 +1171,9 @@
 
 execute_load_bios_u16:
   region_check_align 0, 1, 0, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1199,9 +1200,18 @@
   load_u16 (iwram + 0x8000)
 
 execute_load_io_u16:
-  translate_region_align 4, 1, 0, patch_load_u16, io_registers, 0xFFF
+  region_check 4, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16 io_registers
 
+1:
+  open_load16_core
+  nop
+
 execute_load_palette_u16:
   translate_region_align 5, 1, 0, patch_load_u16, palette_ram, 0x3FF
   load_u16 palette_ram
@@ -1250,9 +1260,9 @@
 
 execute_load_bios_u16u:
   region_check_align 0, 1, 1, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1280,9 +1290,18 @@
   load_u16_unaligned (iwram + 0x8000)
 
 execute_load_io_u16u:
-  translate_region_align 4, 1, 1, patch_load_u16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16_unaligned io_registers
 
+1:
+  open_load16_core
+  ror $2, $2, 8
+
 execute_load_palette_u16u:
   translate_region_align 5, 1, 1, patch_load_u16, palette_ram, 0x3FE
   load_u16_unaligned palette_ram
@@ -1341,6 +1360,7 @@
   .long execute_load_gamepakA_u16 # 0x0A gamepak
   .long execute_load_gamepakB_u16 # 0x0B gamepak
   .long execute_load_gamepakC_u16 # 0x0C gamepak
+
   .long execute_load_eeprom_u16   # 0x0D gamepak/eeprom
   .long execute_load_backup_u16   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u16     # 0x0F open
@@ -1405,9 +1425,9 @@
 
 execute_load_bios_s16:
   region_check_align 0, 1, 0, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1435,9 +1455,18 @@
   load_s16 (iwram + 0x8000)
 
 execute_load_io_s16:
-  translate_region_align 4, 1, 0, patch_load_s16, io_registers, 0xFFF
+  region_check_align 4, 1, 0, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16 io_registers
 
+1:
+  open_load16_core
+  seh $2, $2
+
 execute_load_palette_s16:
   translate_region_align 5, 1, 0, patch_load_s16, palette_ram, 0x3FF
   load_s16 palette_ram
@@ -1486,9 +1515,9 @@
 
 execute_load_bios_s16u:
   region_check_align 0, 1, 1, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1515,9 +1544,18 @@
   load_s16_unaligned (iwram + 0x8000)
 
 execute_load_io_s16u:
-  translate_region_align 4, 1, 1, patch_load_s16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16_unaligned io_registers
 
+1:
+  open_load16_core
+  seb $2, $2
+
 execute_load_palette_s16u:
   translate_region_align 5, 1, 1, patch_load_s16, palette_ram, 0x3FE
   load_s16_unaligned palette_ram
@@ -1605,9 +1643,9 @@
 
 execute_load_bios_u32:
   region_check_align 0, 2, 0, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1634,9 +1672,18 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32:
-  translate_region_align 4, 2, 0, patch_load_u32, io_registers, 0xFFF
+  region_check_align 4, 2, 0, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_core
+  nop
+
 execute_load_palette_u32:
   translate_region_align 5, 2, 0, patch_load_u32, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -1685,9 +1732,9 @@
 
 execute_load_bios_u32u1:
   region_check_align 0, 2, 1, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1712,9 +1759,18 @@
   load_u32_unaligned (iwram + 0x8000), 1
 
 execute_load_io_u32u1:
-  translate_region_align 4, 2, 1, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 1, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 1
 
+1:
+  open_load32_core
+  ror $2, $2, 8
+
 execute_load_palette_u32u1:
   translate_region_align 5, 2, 1, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 1
@@ -1763,9 +1819,9 @@
 
 execute_load_bios_u32u2:
   region_check_align 0, 2, 2, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1790,9 +1846,18 @@
   load_u32_unaligned (iwram + 0x8000), 2
 
 execute_load_io_u32u2:
-  translate_region_align 4, 2, 2, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 2, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 2
 
+1:
+  open_load32_core
+  ror $2, $2, 16
+
 execute_load_palette_u32u2:
   translate_region_align 5, 2, 2, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 2
@@ -1840,9 +1905,9 @@
 
 execute_load_bios_u32u3:
   region_check_align 0, 2, 3, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1867,9 +1932,18 @@
   load_u32_unaligned (iwram + 0x8000), 3
 
 execute_load_io_u32u3:
-  translate_region_align 4, 2, 3, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 3, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 3
 
+1:
+  open_load32_core
+  ror $2, $2, 24
+
 execute_load_palette_u32u3:
   translate_region_align 5, 2, 3, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 3
@@ -1928,6 +2002,7 @@
   .long execute_load_gamepakA_u32 # 0x0A gamepak
   .long execute_load_gamepakB_u32 # 0x0B gamepak
   .long execute_load_gamepakC_u32 # 0x0C gamepak
+
   .long execute_load_eeprom_u32   # 0x0D gamepak/eeprom
   .long execute_load_backup_u32   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u32     # 0x0F open
@@ -1992,9 +2067,9 @@
 
 execute_load_bios_u32a:
   region_check 0, patch_load_u32a
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -2008,7 +2083,6 @@
 
 2:
   open_load32_a
-  nop
 
 execute_load_ewram_u32a:
   translate_region_ewram patch_load_u32a
@@ -2020,9 +2094,17 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32a:
-  translate_region 4, patch_load_u32a, io_registers, 0xFFF
+  region_check 4, patch_load_u32a
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_a
+
 execute_load_palette_u32a:
   translate_region 5, patch_load_u32a, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -2060,7 +2142,6 @@
 
 execute_load_backup_u32a:
   backup_load_a patch_load_u32a
-  nop
 
 execute_load_open_u32a:
   open_load32_a patch_load_u32a
@@ -2106,14 +2187,16 @@
 
 execute_store_io_u8:
   region_check 4, patch_store_u8
-  andi $5, $5, 0xFF               # make value 8bit
+  andi $5, $5, 0xFF               # make value 8bit (delay)
   andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register8          # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2124,6 +2207,7 @@
   andi $4, $4, 0x3FE              # align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2137,10 +2221,7 @@
   store_u8_double vram
 
 execute_store_oam_u8:
-  translate_region 7, patch_store_u8, oam_ram, 0x3FE
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  store_u8_double oam_ram
+  ignore_region 7, patch_store_u8 # Write 8bit data is ignore
 
 execute_store_ignore8_u8:
   ignore_region 8, patch_store_u8
@@ -2207,14 +2288,16 @@
 
 execute_store_io_u16:
   region_check 4, patch_store_u16
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $5, $5, 0xFFFF             # make value 16bit (delay)
   andi $4, $4, 0x3FE              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register16         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2224,6 +2307,7 @@
   andi $4, $4, 0x3FE              # wrap/align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2312,12 +2396,14 @@
   region_check 4, patch_store_u32
   nop
   andi $4, $4, 0x3FC              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register32         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2421,21 +2507,18 @@
 
 execute_store_io_u32a:
   region_check 4, patch_store_u32a
-  nop
+  sw $ra, REG_SAVE2($16)          # save ra (delay)
   sw $6, REG_SAVE($16)            # save a2
-  sw $ra, REG_SAVE2($16)          # save ra
-
-  andi $4, $4, 0x3FC              # wrap around/align address
 
   save_registers
   jal write_io_register32         # write the value out
-  nop
+  andi $4, $4, 0x3FC              # wrap around/align address (delay)
 
   restore_registers
 
   lw $ra, REG_SAVE2($16)          # restore ra
   jr $ra
-  lw $6, REG_SAVE($16)            # restore a2
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 execute_store_palette_u32a:
   region_check 5, patch_store_u32a
@@ -2495,22 +2578,22 @@
   ignore_high patch_store_u32a
 
 store_u32a_ftable:
-  .long execute_store_ignore0_u32a# 0x00 BIOS
-  .long execute_store_ignore1_u32a# 0x01 open address
-  .long execute_store_ewram_u32a  # 0x02 EWRAM
-  .long execute_store_iwram_u32a  # 0x03 IWRAM
-  .long execute_store_io_u32a     # 0x04 I/O registers
-  .long execute_store_palette_u32a# 0x05 Palette RAM
-  .long execute_store_vram_u32a   # 0x06 VRAM
-  .long execute_store_oam_u32a    # 0x07 OAM RAM
-  .long execute_store_ignore8_u32a# 0x08 gamepak
-  .long execute_store_ignore9_u32a# 0x09 gamepak
-  .long execute_store_ignoreA_u32a# 0x0A gamepak
-  .long execute_store_ignoreB_u32a# 0x0B gamepak
-  .long execute_store_ignoreC_u32a# 0x0C gamepak
-  .long execute_store_eeprom_u32a # 0x0D gamepak/eeprom
-  .long execute_store_ignoreE_u32a# 0x0E Flash ROM/SRAM
-  .long execute_store_ignoreF_u32a# 0x0F open address
+  .long execute_store_ignore0_u32a # 0x00 BIOS
+  .long execute_store_ignore1_u32a # 0x01 open address
+  .long execute_store_ewram_u32a   # 0x02 EWRAM
+  .long execute_store_iwram_u32a   # 0x03 IWRAM
+  .long execute_store_io_u32a      # 0x04 I/O registers
+  .long execute_store_palette_u32a # 0x05 Palette RAM
+  .long execute_store_vram_u32a    # 0x06 VRAM
+  .long execute_store_oam_u32a     # 0x07 OAM RAM
+  .long execute_store_ignore8_u32a # 0x08 gamepak
+  .long execute_store_ignore9_u32a # 0x09 gamepak
+  .long execute_store_ignoreA_u32a # 0x0A gamepak
+  .long execute_store_ignoreB_u32a # 0x0B gamepak
+  .long execute_store_ignoreC_u32a # 0x0C gamepak
+  .long execute_store_eeprom_u32a  # 0x0D gamepak/eeprom
+  .long execute_store_ignoreE_u32a # 0x0E Flash ROM/SRAM
+  .long execute_store_ignoreF_u32a # 0x0F open address
 
 patch_store_u32a:
   patch_handler store_u32a_ftable, 0x0F
@@ -2521,7 +2604,7 @@
 execute_load_full_u8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_u8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2534,9 +2617,11 @@
 ext_load_u8:
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)                   # store return address
+
   save_registers
   jal read_memory8                # read the value
   nop
+
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # return
@@ -2546,7 +2631,7 @@
 execute_load_full_s8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_s8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2573,7 +2658,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_u16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2581,7 +2666,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lhu $2, ($1)                    # read the value
+  lhu $2, ($1)                    # read the value (delay)
 
 ext_load_u16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2599,7 +2684,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_s16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2607,7 +2692,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lh $2, ($1)                     # read the value
+  lh $2, ($1)                     # read the value (delay)
 
 ext_load_s16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2626,7 +2711,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 2                # or unaligned (bottom two bits)
   bne $1, $0, ext_load_u32        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2634,7 +2719,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_load_u32:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2650,7 +2735,7 @@
 #execute_aligned_load32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_load32  # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($1)
@@ -2658,7 +2743,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_aligned_load32:
   addiu $sp, $sp, -8              # make room on the stack for $ra
@@ -2689,12 +2774,8 @@
   nop
   collapse_flags                  # make sure flags are good for update_gba
 
-alert_loop:
   jal update_gba                  # process the next event
   nop
-  lw $1, CPU_HALT_STATE($16)      # check if CPU is sleeping
-  bne $1, $0, alert_loop          # see if it hasn't changed
-  nop
 
   addu $17, $2, $0                # $17 = new cycle counter
   lw $4, REG_PC($16)              # $4 = new PC
@@ -2705,20 +2786,19 @@
 irq_alert:
   restore_registers
   j lookup_pc                     # PC has changed, get a new one
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 no_alert:
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 smc_dma:
-  addiu $sp, $sp, 4               # fix the stack
   jal flush_translation_cache_ram # flush translation cache
   nop
   j lookup_pc
-  nop
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 ext_store_eeprom:
@@ -2730,14 +2810,14 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 # 8bit ext memory routines
 
 ext_store_io8:
   andi $5, $5, 0xFF               # make value 8bit
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2747,34 +2827,27 @@
   nop
 
 ext_store_palette8:
+  ins $5, $5, 8, 8                # value = (value << 8) | value
   j ext_store_palette16b          # perform 16bit palette write
   andi $4, $4, 0x3FE              # wrap + align (delay)
 
 ext_store_vram8:
   ins $5, $5, 8, 8                # value = (value << 8) | value
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
   ins $4, $0, 0, 1                # align out bottom bit
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # if $4 >= $1 then $1 = 0 else $1 = 1
-  bne $1, $0, ext_store_vram8b    # if $1 != 0 then j ext_store_vram8b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram8b   # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram8b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
 
 ext_store_oam8:
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  andi $4, $4, 0x3FE              # wrap around address and align to 16bits
-  ins $5, $5, 8, 8                # value = (value << 8) | value
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
-  jr $ra                          # return
-  sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  jr $ra                          # Write 8bit data is ignore
+  nop
 
 ext_store_backup:
   andi $5, $5, 0xFF               # make value 8bit
@@ -2787,25 +2860,25 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u8_jtable:
-  .long ext_store_ignore  # 0x00 BIOS
-  .long ext_store_ignore  # 0x01 invalid
+  .long ext_store_ignore    # 0x00 BIOS
+  .long ext_store_ignore    # 0x01 invalid
   .long ext_store_ignore    # 0x02 EWRAM
   .long ext_store_ignore    # 0x03 IWRAM
   .long ext_store_io8       # 0x04 I/O registers
   .long ext_store_palette8  # 0x05 Palette RAM
   .long ext_store_vram8     # 0x06 VRAM
   .long ext_store_oam8      # 0x07 OAM RAM
-  .long ext_store_ignore  # 0x08 gamepak (no RTC accepted in 8bit)
-  .long ext_store_ignore  # 0x09 gamepak, ignore
-  .long ext_store_ignore  # 0x0A gamepak, ignore
-  .long ext_store_ignore  # 0x0B gamepak, ignore
-  .long ext_store_ignore  # 0x0C gamepak, ignore
-  .long ext_store_eeprom   # 0x0D EEPROM (possibly)
-  .long ext_store_backup   # 0x0E Flash ROM/SRAM
-  .long ext_store_ignore  # 0x0F invalid
+  .long ext_store_ignore    # 0x08 gamepak (no RTC accepted in 8bit)
+  .long ext_store_ignore    # 0x09 gamepak, ignore
+  .long ext_store_ignore    # 0x0A gamepak, ignore
+  .long ext_store_ignore    # 0x0B gamepak, ignore
+  .long ext_store_ignore    # 0x0C gamepak, ignore
+  .long ext_store_eeprom    # 0x0D EEPROM (possibly)
+  .long ext_store_backup    # 0x0E Flash ROM/SRAM
+  .long ext_store_ignore    # 0x0F invalid
 
 
 
@@ -2844,7 +2917,7 @@
 # 16bit ext memory routines
 
 ext_store_io16:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   andi $5, $5, 0xFFFF             # make value 16bit
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
@@ -2861,6 +2934,7 @@
   lui $2, %hi(palette_ram)
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2870,15 +2944,13 @@
   sh $1, %lo(palette_ram_converted)($2)
 
 ext_store_vram16:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram16b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram16b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram16b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2886,6 +2958,7 @@
 ext_store_oam16:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -2893,7 +2966,7 @@
   sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
 
 ext_store_rtc:
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $4, $4, 0xFF               # wrap address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2902,7 +2975,7 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u16_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -2952,15 +3025,10 @@
 
 
 
-
-
-
-
-
 # 32bit ext memory routines
 
 ext_store_io32:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2979,15 +3047,13 @@
   addu $ra, $6, $0                # restore return address (delay)
 
 ext_store_vram32:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram32b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram32b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram32b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sw $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2995,6 +3061,7 @@
 ext_store_oam32:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -3031,6 +3098,7 @@
   nop
 
 #execute_store_u32:
+execute_store_full_u32:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_store_u32       # if it is, perform an extended write
   srl $2, $4, 15                  # $1 = page number of address (delay slot)
@@ -3050,20 +3118,22 @@
 # 32bit ext aligned, non a2 destroying routines
 
 ext_store_io32a:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register32         # write the value out
-  sw $6, REG_SAVE($16)            # save a2
-  lw $6, REG_SAVE($16)            # restore a2
+  sw $6, REG_SAVE($16)            # save a2 (delay)
+
   j write_io_epilogue             # handle any state changes
-  nop
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 ext_store_palette32a:
   sw $ra, REG_SAVE($16)           # save return address
   jal ext_store_palette16b        # write out palette entry
   andi $4, 0x3FF                  # wrap address (delay)
+
   addiu $4, $4, 2                 # go to next location
   srl $5, $5, 16                  # shift to next 16bit value
   j ext_store_palette16b          # write out next palette entry
@@ -3101,7 +3171,7 @@
 #execute_aligned_store32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_store32 # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_write[address >> 15]
   lw $1, 256($1)
@@ -3149,31 +3219,36 @@
   lw $1, CPU_MODE($16)            # $1 = cpu_mode
   lui $2, %hi(spsr)
   sll $1, $1, 2                   # adjust to word offset size
-  addu $2, $2, $1
+  addu $1, $2, $1
   jr $ra                          # return
-  lw $2, %lo(spsr)($2)            # $2 = spsr[cpu_mode] (delay slot)
+  lw $2, %lo(spsr)($1)            # $2 = spsr[cpu_mode] (delay slot)
 
 # Switch into SWI, has to collapse flags
 # $4: Current pc
 
 execute_swi:
-  add $sp, $sp, -4                # push $ra
-  sw $ra, ($sp)
   lui $1, %hi(SUPERVISOR_LR)
   sw $4, %lo(SUPERVISOR_LR)($1)   # store next PC in the supervisor's LR
   collapse_flags                  # get cpsr in $2
   lui $5, %hi(SUPERVISOR_SPSR)
   sw $2, %lo(SUPERVISOR_SPSR)($5) # save cpsr in SUPERVISOR_CPSR
+
+  addiu $sp, $sp, -4              # push $ra
+  sw $ra, ($sp)
+
   ins $2, $0, 0, 6                # zero out bottom 6 bits of CPSR
   ori $2, 0x13                    # set mode to supervisor
   sw $2, REG_CPSR($16)            # write back CPSR
+
   save_registers
+  jal bios_region_read_allow
+  nop
   jal set_cpu_mode                # set the CPU mode to supervisor
   li $4, 3                        # 3 is supervisor mode (delay slot)
   restore_registers
   lw $ra, ($sp)                   # pop $ra
   jr $ra                          # return
-  add $sp, $sp, 4                 # fix stack (delay slot)
+  addiu $sp, $sp, 4               # fix stack (delay slot)
 
 # $4: pc to restore to
 # returns in $4
@@ -3183,14 +3258,15 @@
 
   beq $1, $0, no_spsr_restore     # only restore if the cpu isn't usermode
   lui $2, %hi(spsr)               # start loading SPSR (delay)
-
   sll $1, $1, 2                   # adjust to word offset size
   addu $2, $2, $1
   lw $1, %lo(spsr)($2)            # $1 = spsr[cpu_mode]
-  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
-  extract_flags_body              # extract flags from $1
+
   addiu $sp, $sp, -4
   sw $ra, ($sp)
+
+  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
+  extract_flags_body              # extract flags from $1
   save_registers
   jal execute_spsr_restore_body   # do the dirty work in this C function
   nop
@@ -3272,15 +3348,15 @@
   sllv $4, $4, $5                 # return (value << shift) (delay)
 
 lsl_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsl_shift_done      # jump if shift == 32
-  andi $22, $4, 1                 # c flag = value & 0x01 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  andi $22, $4, 1                 # c flag = value & 0x01
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsl_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsl_shift_done:
   jr $ra                          # return
-  add $4, $0, $0                  # value = 0 no matter what
+  add $4, $0, $0                  # value = 0 no matter what (delay)
 
 
 execute_lsr_flags_reg:
@@ -3297,11 +3373,11 @@
   srlv $4, $4, $5                 # return (value >> shift) (delay)
 
 lsr_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsr_shift_done      # jump if shift == 32
-  srl $22, $4, 31                 # c flag = value >> 31 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  srl $22, $4, 31                 # c flag = value >> 31
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsr_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsr_shift_done:
   jr $ra                          # return
@@ -3341,28 +3417,17 @@
 # $4: cycle counter argument
 
 execute_arm_translate:
-  addu $17, $4, $0                # load cycle counter register
   lui $16, %hi(reg)               # load base register
   addiu $16, %lo(reg)
-  extract_flags                   # load flag variables
-
-  and $1, $1, 0x20                # see if Thumb bit is set in flags
+  addu $17, $4, $0                # load cycle counter register
 
-  bne $1, $0, 1f
+  jal block_lookup_address_arm    # lookup initial jump address
   lw $4, REG_PC($16)              # load PC into $4 (delay)
 
-  jal block_lookup_address_arm    # lookup initial jump address
-  nop
   restore_registers               # load initial register values
   jr $2                           # jump to return
   nop
 
-1:
-  jal block_lookup_address_thumb  # lookup initial jump address
-  nop
-  restore_registers               # load initial register values
-  jr $2                           # jump to return
-  nop
 
 # sceKernelInvalidateIcacheRange gives me problems, trying this instead
 # Invalidates an n byte region starting at the start address
@@ -3377,9 +3442,7 @@
   nop
 
 iir_loop:
-##  cache 8, ($4)                   # invalidate icache line
-##  cache 8, ($4)                   # do it again for good luck :P
-  cache 0x08, ($4)                # hit invalidate icache line
+  cache 0x08, ($4)                # invalidate icache line
   addiu $2, $2, -1                # next loop iteration
   bne $2, $0, iir_loop            # loop
   addiu $4, $4, 64                # go to next cache line (delay slot)
@@ -3403,6 +3466,8 @@
   jr $ra                          # return
   nop
 
+.align 4
+
 memory_map_read:
   .space 0x8000
 
@@ -3412,5 +3477,3 @@
 memory_map_write:
   .space 0x8000
 
-reg_temp:
-  .space 0x100
Only in 30_new/: psp
diff -ru 30_orig/readme_kai_jp.txt 30_new/readme_kai_jp.txt
--- 30_orig/readme_kai_jp.txt	2007-08-26 00:49:54.960782600 +0900
+++ 30_new/readme_kai_jp.txt	2007-08-05 23:04:12.000000000 +0900
@@ -1,262 +1,271 @@
 -- gameplaySP  Gameboy Advance emulator for Playstation Portable --
 
 -- Release log --
+-UnOfficial gpSP kai 3.1 test 05 svn rev.**
+	カーネルモードで動作するように変更
+		カーネルモードにするため、改変SDLを使用
+	statesaveの日付表示を修正
+		pspsdkのtime()関数が時刻しか返さないため
+	上記に伴い、satesaveファイルのサイズを506947 -> 506951に変更
+		古いファイルも読込み時に自動判別して読み込みます
+		保存時に新しい形式で保存されます
+
 -UnOfficial gpSP kai 3.1 test 04 svn rev.65
-	�v�`�m�C�Y�̒ጸ
-	�`�[�g����30�ɕύX
-	�`�[�g���j���[�̃y�[�W�ؑւɑΉ�
-	�`�[�g���L��ɂȂ�Ȃ��B��̂�C��
-	game cfg�t�@�C����`�[�g�̑��BɑΉ�
-		�̂�game cfg�t�@�C���͍폜���ĉ������A�V������̂�136byte�ɂȂBĂ��܂�
+	プチノイズの低減
+	チート数を30個に変更
+	チートメニューのページ切替に対応
+	チートが有効にならなかったのを修正
+	game cfgファイルをチートの増加に対応
+		昔のgame cfgファイルは削除して下さい、新しいものは136byteになっています
 
 -UnOfficial gpSP kai 3.1 test 03 svn rev.45
-	�X���[�u���̃t���[�Y�ɑΉ�
-		�X���[�u���A��̓��j���[��ʂɂȂ�܂�
+	スリーブ時のフリーズに対応
+		スリーブ復帰後はメニュー画面になります
 
 -UnOfficial gpSP kai 3.1 test 02
-	���傱�BƍœK��
-	�T�E���h�o�b�t�@�̐ݒ��2048�`�ɖ߂���
-	�T�E���h�̒��I�ȃv�`�m�C�Y�̑Ή�
+	ちょこっと最適化
+	サウンドバッファの設定を2048～に戻した
+	サウンドの定期的なプチノイズの対応
 
 -UnOfficial gpSP kai 3.1 test 01
-	�s����BIOS�R�[���𖳎�����悤�ɂ��� 
-		�ꕔ�̓N��ROM�ɑΉ�
-	�T�E���h���﭂�����
-	ARM/THUMB��SBC/RSC���߂�Ē���
-		�h���L�[�R���O3�̉����o�Ă��Ȃ��B��̂ɑΉ� 
-	I/O���W�X�^��0x410�`0x800�ɉ��Ή� 
-		�ꕔ�̓N��ROM�ɑΉ�
+	不正なBIOSコールを無視するようにした 
+		一部の特殊なROMに対応
+	サウンド周りを少し調整
+	ARM/THUMBのSBC/RSC命令を再調整
+		ドンキーコング3の音が出ていなかったのに対応 
+	I/Oレジスタの0x410～0x800に仮対応 
+		一部の特殊なROMに対応
 
 -UnOfficial gpSP kai 3.0
-	�\�[�X�﭂�����
+	ソースを少し整理
 
 -UnOfficial gpSP kai ml 3.00 test 10
-	BIOS�̐ݒ��~�X���Ă����̂�C�� 
-	FPS�\�����ɗ]�v��I/O��\�����Ă����̂�C��
+	BIOSの設定をミスしていたのを修正 
+	FPS表示時に余計なI/Oを表示していたのを修正
 
 -UnOfficial gpSP kai ml 3.00 test 9
-	�o�b�N�A�b�v�Z�[�u�̕s��C�� 
-	�X�N���[���V���b�g��BMP�Ŏ� 
-		PNG���C�u�����͕s�K�v�ɂȂ�܂���
-	�^�C�~���O�ɂ�BẮA�Z�[�u�f�[�^������o�O��C�� 
-	BIOS HALT�鼎� 
-	BIOS�R�[�����𧻓��p�ɒ���
+	バックアップセーブの不具合修正 
+	スクリーンショットをBMPで実装 
+		PNGライブラリは不必要になりました
+	タイミングによっては、セーブデータが壊れるバグを修正 
+	BIOS HALTを仮実装 
+	BIOSコール周りを将来用に調整
 
 -UnOfficial gpSP kai ml 3.00 test 8
-	FF6A�̑Ή�
-		thumb sbc���߂�c flag�̃o�O��C��
-	�X�N���[���V���b�g�Ńn���O�A�b�v����Btest 9�ɂďC���\��
-	rom�㍁[�h���Ȃ��ŏI������ƁA��u�u���[�X�N���[���ɂȂ�̂�C��
-	Kingdom Hearts - Chain of Memories�̃��[�r�[���t���[�Y���Ȃ��ȂB�(�摜�̓{���{���ł���)
+	FF6Aの対応
+		thumb sbc命令のc flagのバグを修正
+	スクリーンショットでハングアップする。test 9にて修正予定
+	romをロードしないで終了すると、一瞬ブルースクリーンになるのを修正
+	Kingdom Hearts - Chain of Memoriesのムービーがフリーズしなくなった(画像はボロボロですが)
 
 -UnOfficial gpSP kai ml 3.00 test 7
-	BIOS�̏�����divArm�ȊO�͌��ɖ߂���
-		�s��������B�����(���x�ʂŎ̂Ă�������̂�����̂ŁA�����͉��Ƃ�������)
-	�c��̃������ƁAROM�p�o�b�t�@�T�C�Y��\������悤�ɂ���
+	BIOSの処理をdivArm以外は元に戻した
+		不具合が多かったため(速度面で捨てがたいものがあるので、将来は何とかしたい)
+	残りのメモリと、ROM用バッファサイズを表示するようにした
 
 -UnOfficial gpSP kai ml 3.00 test 6
-	�T�E���h�̃Y����C�� 
-	���g���C�h�t���[�W�����̃Z�[�u�f�[�^�I���ʂ̃X�e�[�^�X�ُ��C�� 
-	BIOS���divArm,sqrt,cpuset,cpufastset��l�C�e�B�u�Ŏ� 
-		����BIOS�����œ������邽�߂̃e�X�g
-		�L���O�_���n�[�c���N���ł��Ȃ��ȂBĂ܂�
-	Makefile�̏C��
+	サウンドのズレを修正 
+	メトロイドフュージョンのセーブデータ選択画面のステータス異常を修正 
+	BIOS内のdivArm,sqrt,cpuset,cpufastsetをネイティブで実装 
+		将来BIOS無しで動かせるためのテスト
+		キングダムハーツが起動できなくなってます
+	Makefileの修正
 
 -UnOfficial gpSP kai ml 3.00 test 5
-	�^�C�}�̃J�E���^�����Ⳃ�ɏC�� 
-		���O�h�����j�I���̕s��C��
-	Makefile�̏C�� 
-	���̓�_�͓N�ȏ󋵂ł����������Ȃ��Ǝv����̂ŁA�Ƃ肠�������̂܂ܕ�u
-	�T�E���h����ق�̏����œK�� 
-	���񂩂�ver1.0��ver1.5�𓯍�
+	タイマのカウンタ処理をさらに修正 
+		ユグドラユニオンの不具合修正
+	Makefileの修正 
+	この二点は特殊な状況でしか発生しないと思われるので、とりあえずそのまま放置
+	サウンド周りをほんの少し最適化 
+	今回からver1.0とver1.5を同梱
 
 -UnOfficial gpSP kai ml 3.00 test 4
-	RPG�c�N�[���A�h�o���X�̉������������Ȃ�o�O��C��
-		�^�C�}�̃J�E���^������C��
-	�T�E���h�Ƀv�`�v�`�ƃm�C�Y����BĂ����̂ŁAmips_stub.S�̈ꕔ��0.9�ɖ߂���
+	RPGツクールアドバンスの音がおかしくなるバグを修正
+		タイマのカウンタ処理を修正
+	サウンドにプチプチとノイズが入っていたので、mips_stub.Sの一部を0.9に戻した
 
 -UnOfficial gpSP kai ml 3.00 test 3
-	gpSP0.91�ł̕ύX�_��قڎ�荞�݂܂��� 
-		�c��̓f�o�b�O�֌W�̎��ƁAarm_stub.S/arm_emit.h�⻂ꂼ��PSP�p�ɈڐA���邱�Ƃł�
-	32MB��ROM��s����PSP��X���[�v������ƁA���A���Ƀn���O�A�b�v����̂𕔕��I�ɏC��
-		���j���[��\����������ԂŃX���[�v������΁A�n���O�A�b�v���Ȃ��l�ɂ��܂���
-	�T�E���h���﭂��œK���E�����x��
-	��ʕ\�����﭂��œK��
-		��L2�_�ɂ��2�`3FPS��サ�Ă��܂�
-	0.91��game_config.txt�ɓ�{��ROM��ǉ�
+	gpSP0.91での変更点をほぼ取り込みました 
+		残りはデバッグ関係の実装と、arm_stub.S/arm_emit.hをそれぞれPSP用に移植することです
+	32MBのROMを実行時にPSPをスリープさせると、復帰時にハングアップするのを部分的に修正
+		メニューを表示させた状態でスリープさせれば、ハングアップしない様にしました
+	サウンド周りを少し最適化・高精度化
+	画面表示周りを少し最適化
+		上記2点により2～3FPS向上しています
+	0.91のgame_config.txtに日本のROMを追加
 
 -UnOfficial gpSP kai ml 3.00 test 2
-	gpSP0.91�ł̕ύX�_��ꕔ��荞�݂܂��� 
-		FPS�̕\��(�L�[�R���t�B�O�ɂēK���ȃL�[�Ɋ����ĂĎg�p���܂�) 
-		VOL UP/DOWN�͎����Ă��܂���
-	��L�ɂ��msg�t�@�C���̍X�V 
-	HOME�{�^���ŏI���ł��Ȃ��B��̂�C��
+	gpSP0.91での変更点を一部取り込みました 
+		FPSの表示(キーコンフィグにて適当なキーに割当てて使用します) 
+		VOL UP/DOWNは実装していません
+	上記によるmsgファイルの更新 
+	HOMEボタンで終了できなかったのを修正
 
 -UnOfficial gpSP kai ml 3.00 test 1
-	gpSP0.91�ł̕ύX�_��ꕔ��荞�݂܂���
-		cpu���͑啝�ȕύX���K�v�Ȃ��߁A���܂��荞��ł��܂���
-		�ׂ����C����s�BĂ��܂���
-	�C�^���A��̃��b�Z�[�W�t�@�C���̒ǉ�
-	�A�C�R���摜�̒ǉ�
+	gpSP0.91での変更点を一部取り込みました
+		cpu周りは大幅な変更が必要なため、あまり取り込んでいません
+		細かい修正も行っていません
+	イタリア語のメッセージファイルの追加
+	アイコン画像の追加
 		thanks Luca Lefebre
 
 -UnOfficial gpSP kai ml 2.92
-	�}���`�����Q�[�W�ɑΉ�
-		PSP�̌���ݒ�őI�񂾌���̃t�@�C�����Ŏg�p����
-	message.cfg/font.cfg��*.msg/*.fnt�Ƀ��l�[��
-	dir.cfg/*.msg/*.fnt��setting/�̉��Ɉړ�
-	��{�ꂵ���ł��Ȃ��̂ŁA�p��/��{��ȊO�͂��ꂼ�ꏑ�������Ďg�BĂ�������
+	マルチランゲージに対応
+		PSPの言語設定で選んだ言語のファイルを自動で使用する
+	message.cfg/font.cfgを*.msg/*.fntにリネーム
+	dir.cfg/*.msg/*.fntをsetting/の下に移動
+	日本語しかできないので、英語/日本語以外はそれぞれ書き換えて使ってください
 
 -UnOfficial gpSP kai jp 2.91
-	�񐳋K��BIOS�ł�N���ł���悤�ɂ���
-	message.cfg�̒ǉ�
+	非正規のBIOSでも起動できるようにした
+	message.cfgの追加
 
 -UnOfficial gpSP kai jp 2.9
-	���j���[�ł̎��v�\��/�o�b�e���[�c�ʕ\����ǉ�
-	�I������222MHz�ɖ߂��l�ɂ���
-	���j���[���灛��~�{�^���ŃQ�[���ɖ߂鎞�ɁA�Q�[����Ń{�^����F�������Ȃ��l�ɂ���
-		(�{�^��������_�Ŗ߂�܂�) 
-	ROM���̑I��R/L�{�^���ł�5�s���Ƃ̈ړ���ǉ�
-	BBS�Ɋ񂹂�ꂽ���ɂ��ARTC���/mips_stub.S�̏C��
-	��̕\���t�H�[�}�b�g��PSP�̃��W�X�g����Q��
-	1.5�p�̃t�H���_����j���t�@�C����\���ɑΉ�
-	���K��GBA/NDS��BIOS�ŋN���\
-	statesave�̃t�@�C������ROM���ƃX���b�g�ԍ��̊Ԃ�"_"���ꂽ
-	���j���[�̃O���t�B�b�N/�T�E���h�̐ݒ�ɃX�N���[���V���b�g�@�\��ǉ�
-		PNG RGB 24bit�`����dir.cfg�Őݒ肵���t�H���_�ɁAROM�t�@�C����+�N����Ԃŕۑ�����܂�
-	���j���[���ɃA�i���O�L�[�ł̑����ǉ�
-	��L�ɔ���message.cfg/dir.cfg�̕ύX
-	���j���[��ʂ�J�X�^�}�C�Y���₷���悤�ɁA���b�Z�[�W�̏��Ԃ���ւ���
-	message.cfg�̖|��̒ǉ�
-	���j���[�Ƀ`�[�g�t�@�C���̓ǂݍ��݂�ǉ�
-	��Í��̃`�[�g�ɑΉ�
-		�t�H�[�}�b�g��
-			direct_v? �`�[�g��
+	メニューでの時計表示/バッテリー残量表示を追加
+	終了時に222MHzに戻す様にした
+	メニューから○や×ボタンでゲームに戻る時に、ゲーム内でボタンを認識させない様にした
+		(ボタンを放した時点で戻ります) 
+	ROM等の選択時にR/Lボタンでの5行ごとの移動を追加
+	BBSに寄せられた情報による、RTC廻り/mips_stub.Sの修正
+	日時の表示フォーマットにPSPのレジストリを参照
+	1.5用のフォルダ名を破損ファイル非表示に対応
+	正規のGBA/NDSのBIOSで起動可能
+	statesaveのファイル名のROM名とスロット番号の間に"_"を入れた
+	メニューのグラフィック/サウンドの設定にスクリーンショット機能を追加
+		PNG RGB 24bit形式でdir.cfgで設定したフォルダに、ROMファイル名+年月日時間で保存されます
+	メニュー時にアナログキーでの操作を追加
+	上記に伴うmessage.cfg/dir.cfgの変更
+	メニュー画面をカスタマイズしやすいように、メッセージの順番を入れ替えた
+	message.cfgの翻訳の追加
+	メニューにチートファイルの読み込みを追加
+	非暗号のチートに対応
+		フォーマットは
+			direct_v? チート名
 			AAAAAAAA DDDDDDDD
-		direct_v?����Í��p�̎��ʎq�ŁAv1��PAR V1/V2�p�Ev3��PAR V3�p�̈Í����O�̃f�[�^���g����
-		AAAAAAAA���I�y�R�[�h/�A�h���X�ADDDDDDDD���f�[�^
+		direct_v?が非暗号用の識別子で、v1でPAR V1/V2用・v3でPAR V3用の暗号化前のデータが使える
+		AAAAAAAAがオペコード/アドレス、DDDDDDDDがデータ
 
-	�\�[�X����̃r���h��libpng���K�v
+	ソースからのビルドにlibpngが必要
 
 -UnOfficial gpSP kai jp 2.8
-	gpSP0.9��x�[�X�ɂ��܂���~
-	�e�탁�b�Z�[�W�ނ�message.cfg�ɕ���~
-	�t�H���g�̐ݒ�t�@�C��font.cfg��V��~
-	fbm�t�H���g��message.cfg��p�ӂ���Α�����ɑΉ�~
-	�e��f�B���N�g���ݒ�t�@�C��dir.cfg��V��~
-	�T�E���h�o�b�t�@��2048�ŗ�����̂�(�Ƃ肠����)�C��~
-	backup�̕ۑ���I�����ɂ��Ă���ꍇ�AHOME�L�[�ł̏I�����ɂ�backup��ۑ�����悤�ɂ���~
-	backup�̕ۑ���I�����ɂ��Ă���ꍇ�A�ʃQ�[���̃��[�h��s�B��ۂɂ�backup��ۑ�����悤�ɂ���~
-	8�܂ł�idle_loop_eliminate_target�ɑΉ�~
-	�X�e�[�g�Z�[�u/RTC�̎�����PSP�{�̂̐ݒ��g�p����悤�ɂ���~
-
-	cfg�t�@�C���̃t�H�[�}�b�g�ɂ���
-		�s����#�̍s�̓R�����g���ł�
-		�s����!�ȍ~�A��s�܂ł��f�[�^�ł�
-		!�����������ꍇ�A�Ք�ŘA������܂�
-		�P���ɏ��Ԃɓǂݍ���ł��邾���Ȃ̂ŁA���Ԃ�ς���Ɛ���ɓ����܂���
-		1�f�[�^�ɕt��511byte�܂łł��B�������ꍇ����ɓ����܂��� 
-		�G���[�`�F�b�N�͂قƂ�ǂ��Ă��܂���
-		���b�Z�[�W��ҏW����ۂ́A�f�[�^�[���%s,%d���͕K���c���Ă�������
+	gpSP0.9をベースにしました~
+	各種メッセージ類をmessage.cfgに分離~
+	フォントの設定ファイルfont.cfgを新設~
+	fbmフォントとmessage.cfgを用意すれば多言語に対応~
+	各種ディレクトリ設定ファイルdir.cfgを新設~
+	サウンドバッファが2048で落ちるのを(とりあえず)修正~
+	backupの保存を終了時にしている場合、HOMEキーでの終了時にもbackupを保存するようにした~
+	backupの保存を終了時にしている場合、別ゲームのロードを行った際にもbackupを保存するようにした~
+	8個までのidle_loop_eliminate_targetに対応~
+	ステートセーブ/RTCの時刻にPSP本体の設定を使用するようにした~
+
+	cfgファイルのフォーマットについて
+		行頭が#の行はコメント文です
+		行頭の!以降、改行までがデータです
+		!文が続いた場合、内部で連結されます
+		単純に順番に読み込んでいるだけなので、順番を変えると正常に動きません
+		1データに付き511byteまでです。超えた場合正常に動きません 
+		エラーチェックはほとんどしていません
+		メッセージを編集する際は、データー内の%s,%d等は必ず残してください
 
 -gpSP kai 2.7
-	����
+	欠番
 
 -gpSP kai 2.6
-	kai 2.5�̃o�O�C��
-		vram�Ǎ�/�������̃o�O�C��(�ďC��)
-			0x18000�ɓǍ�/���������Ƃ��̏C��
-		vram��ꕔ�j�󂵂Ă����̂�C��
-		�T�E���h��RL�`�����l���̓��ւ�(gbc�݊��T�E���h��C��)(96�����)
-	������/�œK��
-		�`�[�g�R�[�h��W����OFF�ɂ���
-			�K�v�Ȃ��make -e"OPT=-DCHEAT"�Ńr���h���Ă�������
-		���C�����[�v�̕s�v�ȕϐ������폜
-		mips_stub.S�̈ꕔ��delay slot��g�p����悤�ɂ���(5�����)
-		mips_stub.S�̃}�N����W�J��delay slot��g�p����l�ɂ���
-	�V�K�Ή�
-		�����Y�d�S�𓮂��悤�ɂ���(5�����)
-
-	�g��
-	debug���[�h�̒ǉ�
-		make -e"OPT=-DDEBUG_MODE"�Ńr���h���邱�Ƃɂ��debug���[�h���ǉB���܂�
-		��ʃT�C�Y��debug�ɂ��ā�+�㉺�ɂĕ\�����[�h�ؑւł�
-		mode 0 �\������
-		mode 1 VBALNK�����݂ɓ���ĕ\��
-		mode 2 HBLANK�����݂ɓ���ĕ\��
+	kai 2.5のバグ修正
+		vram読込/書込時のバグ修正(再修正)
+			0x18000に読込/書込したときの修正
+		vramを一部破壊していたのを修正
+		サウンドのRLチャンネルの入れ替え(gbc互換サウンドも修正)(96氏より)
+	高速化/最適化
+		チートコードを標準でOFFにした
+			必要ならばmake -e"OPT=-DCHEAT"でビルドしてください
+		メインループの不要な変数操作を削除
+		mips_stub.Sの一部をdelay slotを使用するようにした(5氏より)
+		mips_stub.Sのマクロを展開しdelay slotを使用する様にした
+	新規対応
+		桃太郎電鉄を動くようにした(5氏より)
+
+	拡張
+	debugモードの追加
+		make -e"OPT=-DDEBUG_MODE"でビルドすることによりdebugモードが追加されます
+		画面サイズをdebugにして△+上下にて表示モード切替です
+		mode 0 表示無し
+		mode 1 VBALNK割込みに同期して表示
+		mode 2 HBLANK割込みに同期して表示
 
 	for eLoader
-		�N���b�N�̐ݒ��s��Ȃ��悤�ɂ���
-		eloader�Őݒ肵���N���b�N�ŋN������Ǝv���܂�
+		クロックの設定を行わないようにした
+		eloaderで設定したクロックで起動すると思われます
 
-	�r���h���̃I�v�V�����ɂ���
-		make kxploit ��1.5�p�̎s�t�@�C���쐬���܂�
-		make -e"OPT=�`" �ŃI�v�V������ݒ肵�܂�
-			OPT=-DDEBUG_MODE	�f�o�b�O���[�h
-			OPT=-DCHEAT			�`�[�g�L��
-			OPT=-DELOADER		eLoader�Ή�
-		��)1.5�p�s�t�@�C����eLoader,�f�o�b�O,�`�[�g�Ή��ō쐬
+	ビルド時のオプションについて
+		make kxploit で1.5用の実行ファイル作成します
+		make -e"OPT=～" でオプションを設定します
+			OPT=-DDEBUG_MODE	デバッグモード
+			OPT=-DCHEAT			チート有効
+			OPT=-DELOADER		eLoader対応
+		例)1.5用実行ファイルをeLoader,デバッグ,チート対応で作成
 			make kxploit -e"OPT=-DDEBUG_MODE -DCHEAT -DELOADER"
 
 -gpSP kai 2.5
-	�Ȉ�/�o�O�̑��� �`�[�g�@�\�̒ǉ�
-		�A�h���X0x02000000�`(ewram)�ƁA0x03000000�`(iwram)�ɑΉ�
-		1byte�̏������̂ݑΉ�
-
-		�t�@�C������"ROM�t�@�C����".cht�ł��BROM�t�@�C���Ɠ����ꏊ�ɂ����Ă�������
-		ROM�t�@�C������"rpg.gba"�̏ꍇ�A"rpg.cht"�ł�
-
-		�t�@�C���̃t�H�[�}�b�g��
-			#�R�����g�s
-			 �R�[�h����:�A�h���X:byte data(16�i)�ł��B
-		��
+	簡易/バグの多い チート機能の追加
+		アドレス0x02000000～(ewram)と、0x03000000～(iwram)に対応
+		1byteの書換えのみ対応
+
+		ファイル名は"ROMファイル名".chtです。ROMファイルと同じ場所においてください
+		ROMファイル名が"rpg.gba"の場合、"rpg.cht"です
+
+		ファイルのフォーマットは
+			#コメント行
+			 コード名称:アドレス:byte data(16進)です。
+		例
 			#cheat test
 			test 01:0200123F:6F
 
-		�R�[�h�̃T�[�`��`�[�g��ON/OFF�͂܂��o���܂���B
+		コードのサーチやチートのON/OFFはまだ出来ません。
 
-	vram�������̃o�O�C��(130�����)
-	sram�T�C�Y��������̃o�O�C��
-	�J�[�r�B�̕s��C��(5/104�����)
-	�T�E���h��RL�`�����l���̓��ւ�(96�����)
-	���_���b�g�i�r�̕s��C��(5/104�����)
+	vram書込時のバグ修正(130氏より)
+	sramサイズ自動判定のバグ修正
+	カービィの不具合修正(5/104氏より)
+	サウンドのRLチャンネルの入れ替え(96氏より)
+	メダロットナビの不具合修正(5/104氏より)
 
 	for eLoader
-	8MB�ȏ��ROM�̕������[�h�ɑΉ�
-		8MB�ȏ��ROM��ZIP���k�ɑΉ����Ă��܂���
-		Clock Speed 300MHz/Bus Speed 150MHz�ɐݒ�
+	8MB以上のROMの分割ロードに対応
+		8MB以上のROMはZIP圧縮に対応していません
+		Clock Speed 300MHz/Bus Speed 150MHzに設定
 
 -gpSP kai 2.4
-	��ʂ̕\�����[�h��ǉAB
-		unscaled 3:2				(��̃��[�h)
-		scaled 3:2(LINEAR)			(��̃��[�h)
-		fullscreen 16:9(LINEAR)		(��̃��[�h)
-		scaled 3:2(NEAREST)			(�t�B���^�[��g�p���Ȃ����[�h)
-		fullscreen 16:9(NEAREST)	(�t�B���^�[��g�p���Ȃ����[�h)
-		scaled 1.75(NEAREST)		(1.75�o�C���[�h/�㉺ 4dot���؂�܂�)
+	画面の表示モードを追加。
+		unscaled 3:2				(既存のモード)
+		scaled 3:2(LINEAR)			(既存のモード)
+		fullscreen 16:9(LINEAR)		(既存のモード)
+		scaled 3:2(NEAREST)			(フィルターを使用しないモード)
+		fullscreen 16:9(NEAREST)	(フィルターを使用しないモード)
+		scaled 1.75(NEAREST)		(1.75バイモード/上下 4dotが切れます)
 
 -gpSP kai 2.3
-	sound I/O��bug fix�B
-		�������̃Q�[���������悤�ɂȂ�܂����B
+	sound I/Oのbug fix。
+		いくつかのゲームが動くようになりました。
 
 -gpSP kai 2.2
-	save state�̍������B
+	save stateの高速化。
 
 -gpSP kai 2.1
-	idle_loop_eliminate_target�̕����l�ɑΉ��B
+	idle_loop_eliminate_targetの複数値に対応。
 
 -gpSP kai 2
-	sound buffer size�̃R���t�B�O��ǉAB
-		2048�`12288�܂Őݒ�\�B(�f�t�H���g��2048/�I���W�i����8192)
+	sound buffer sizeのコンフィグを追加。
+		2048～12288まで設定可能。(デフォルトは2048/オリジナルは8192)
 
-	�ݒ肵��sound buffer size��GAME CFG�t�@�C���ɕۑ������悤�ɂ����B
-		GAME CFG�t�@�C���̃T�C�Y��12byte -> 16byte�ɕύX�B
+	設定したsound buffer sizeをGAME CFGファイルに保存されるようにした。
+		GAME CFGファイルのサイズが12byte -> 16byteに変更。
 
 -gpSP kai (1)
-	�A�i���O�p�b�h�̃R���t�B�O��ǉ�
+	アナログパッドのコンフィグを追加
 
-	�ݒ肵��sound buffer size��gpSP CFG�t�@�C���ɕۑ������悤�ɂ����B
-		gpSP CFG�t�@�C���̃T�C�Y��56byte -> 72byte�ɕύX�B
+	設定したsound buffer sizeをgpSP CFGファイルに保存されるようにした。
+		gpSP CFGファイルのサイズが56byte -> 72byteに変更。
 
 takka takka@tfact.net
 http://www.tfact.jp/psp/wiki/
diff -ru 30_orig/sound.c 30_new/sound.c
--- 30_orig/sound.c	2007-08-26 00:49:55.088782600 +0900
+++ 30_new/sound.c	2007-08-06 23:47:50.000000000 +0900
@@ -25,7 +25,7 @@
 direct_sound_struct direct_sound_channel[2];
 gbc_sound_struct gbc_sound_channel[4];
 
-//u32 sound_frequency = 44100;
+u32 sound_frequency = 44100;
 
 SDL_AudioSpec sound_settings;
 SDL_mutex *sound_mutex;
@@ -43,38 +43,24 @@
 
 u32 gbc_sound_wave_update;
 
-u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
+// u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
 
 void sound_callback(void *userdata, Uint8 *stream, int length);
 void init_noise_table(u32 *table, u32 period, u32 bit_length);
 
-// Queue 1, 2, or 4 samples to the top of the DS FIFO, wrap around circularly
 
-#define sound_timer_queue(size, value)                                        \
-  *((s##size *)(ds->fifo + ds->fifo_top)) = value;                            \
-  ds->fifo_top = (ds->fifo_top + 1) % 32;                                     \
-
-void sound_timer_queue8(u32 channel, u8 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  sound_timer_queue(8, value);
-}
-
-void sound_timer_queue16(u32 channel, u16 value)
+/* マジカルバケーションの不具合修正 */
+void sound_timer_queue32(u8 channel)
 {
   direct_sound_struct *ds = direct_sound_channel + channel;
-  sound_timer_queue(8, value & 0xFF);
-  sound_timer_queue(8, value >> 8);
-}
+  u8 offset = channel * 4;
+  u8 i;
 
-void sound_timer_queue32(u32 channel, u32 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-
-  sound_timer_queue(8, value & 0xFF);
-  sound_timer_queue(8, (value >> 8) & 0xFF);
-  sound_timer_queue(8, (value >> 16) & 0xFF);
-  sound_timer_queue(8, value >> 24);
+  for(i = 0xA0; i <= 0xA3; i++)
+  {
+    ds->fifo[ds->fifo_top] = ADDRESS8(io_registers, i + offset);
+    ds->fifo_top = (ds->fifo_top + 1) % 32;
+  }
 }
 
 // Unqueue 1 sample from the base of the DS FIFO and place it on the audio
@@ -153,7 +139,15 @@
   ds->buffer_index = buffer_index;
   ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
 
-  if(((ds->fifo_top - ds->fifo_base) % 32) <= 16)
+  /* マジカルバケーションで動作が遅くなるのが改善される */
+  u8 fifo_length;
+
+  if(ds->fifo_top > ds->fifo_base)
+    fifo_length = ds->fifo_top - ds->fifo_base;
+  else
+    fifo_length = ds->fifo_top + (32 - ds->fifo_base);
+
+  if(fifo_length <= 16)
   {
     if(dma[1].direct_sound_channel == channel)
       dma_transfer(dma + 1);
@@ -165,7 +159,7 @@
 
 void sound_reset_fifo(u32 channel)
 {
-  direct_sound_struct *ds = direct_sound_channel;
+  direct_sound_struct *ds = direct_sound_channel + channel;
 
   memset(ds->fifo, 0, 32);
 }
@@ -185,7 +179,7 @@
   { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
   { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
   { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 },
+  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 }
 };
 
 s8 wave_samples[64];
@@ -263,14 +257,15 @@
       else                                                                    \
         rate = rate + (rate >> gs->sweep_shift);                              \
                                                                               \
-      if(rate > 2048) {                                                       \
-        rate = 0;                                                             \
-        frequency_step = 0;                                                   \
-      } else {                                                                \
-        frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)  \
-        / SOUND_FREQUENCY);                                                   \
+      if(rate > 2047)                                                         \
+      {                                                                       \
+        gs->active_flag = 0;                                                  \
+        break;                                                                \
       }                                                                       \
                                                                               \
+      frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)    \
+       / sound_frequency);                                                    \
+                                                                              \
       gs->frequency_step = frequency_step;                                    \
       gs->rate = rate;                                                        \
                                                                               \
@@ -317,6 +312,8 @@
   tick_counter += gbc_sound_tick_step;                                        \
   if(tick_counter > 0xFFFF)                                                   \
   {                                                                           \
+    tick_counter &= 0xFFFF;                                                   \
+                                                                              \
     if(gs->length_status)                                                     \
     {                                                                         \
       u32 length_ticks = gs->length_ticks - 1;                                \
@@ -331,8 +328,6 @@
                                                                               \
     update_tone_##envelope_op();                                              \
     update_tone_##sweep_op();                                                 \
-                                                                              \
-    tick_counter &= 0xFFFF;                                                   \
   }                                                                           \
 
 #define gbc_sound_render_sample_right()                                       \
@@ -414,7 +409,7 @@
   }                                                                           \
                                                                               \
   gs->sample_index = sample_index;                                            \
-  gs->tick_counter = tick_counter;                                            \
+  gs->tick_counter = tick_counter                                             \
 
 #define gbc_sound_load_wave_ram(bank)                                         \
   wave_bank = wave_samples + (bank * 32);                                     \
@@ -428,7 +423,7 @@
 void update_gbc_sound(u32 cpu_ticks)
 {
   FIXED16_16 buffer_ticks = FLOAT_TO_FP16_16(((float)(cpu_ticks -
-   gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / 16777216.0);
+   gbc_sound_last_cpu_ticks) * sound_frequency) / 16777216.0);
   u32 i, i2;
   gbc_sound_struct *gs = gbc_sound_channel;
   FIXED16_16 sample_index, frequency_step;
@@ -465,7 +460,7 @@
       }
       if(game_config_frameskip_type == auto_frameskip)
       {
-//        sceDisplayWaitVblankStart();
+        sceDisplayWaitVblankStart();
         real_frame_count = 0;
         virtual_frame_count = 0;
       }
@@ -495,15 +490,7 @@
     gs = gbc_sound_channel + 2;
     if(gbc_sound_wave_update)
     {
-      if(gs->wave_bank == 1)
-      {
-        gbc_sound_load_wave_ram(1);
-      }
-      else
-      {
-        gbc_sound_load_wave_ram(0);
-      }
-
+      gbc_sound_load_wave_ram(gs->wave_bank);
       gbc_sound_wave_update = 0;
     }
 
@@ -579,6 +566,10 @@
     while (_length--) *ptr1++ = *ptr2++ = 0;                                  \
   }                                                                           \
 
+
+/*--------------------------------------------------------
+  サウンド コールバック
+--------------------------------------------------------*/
 void sound_callback(void *userdata, Uint8 *stream, int length)
 {
   u32 sample_length = length / 2;
@@ -717,11 +708,10 @@
 void init_sound()
 {
   audio_buffer_size = (audio_buffer_size_number * 1024) + 2048;
-  audio_buffer_size_x2 = audio_buffer_size * 2;
 
   SDL_AudioSpec desired_spec =
   {
-    SOUND_FREQUENCY,
+    sound_frequency,
     AUDIO_S16,
     2,
     0,
@@ -732,17 +722,21 @@
     NULL
   };
 
-  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
+  SDL_OpenAudio(&desired_spec, &sound_settings);
+  sound_mutex = SDL_CreateMutex();
+  sound_cv = SDL_CreateCond();
+
+  sound_frequency = sound_settings.freq;
+  audio_buffer_size = sound_settings.size;
+  audio_buffer_size_x2 = audio_buffer_size * 3;
+
+  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / sound_frequency);
 
   init_noise_table(noise_table15, 32767, 14);
   init_noise_table(noise_table7, 127, 6);
 
   reset_sound();
 
-  SDL_OpenAudio(&desired_spec, &sound_settings);
-//  sound_frequency = sound_settings.freq;
-  sound_mutex = SDL_CreateMutex();
-  sound_cv = SDL_CreateCond();
   SDL_PauseAudio(0);
 }
 
diff -ru 30_orig/sound.h 30_new/sound.h
--- 30_orig/sound.h	2007-08-26 00:49:55.143782600 +0900
+++ 30_new/sound.h	2007-08-06 23:46:42.000000000 +0900
@@ -103,6 +103,7 @@
 extern u32 gbc_sound_master_volume_right;
 extern u32 gbc_sound_master_volume;
 
+extern u32 sound_frequency;
 extern u32 sound_on;
 
 extern u32 global_enable_audio;
@@ -112,9 +113,7 @@
 extern SDL_mutex *sound_mutex;
 extern SDL_cond *sound_cv;
 
-void sound_timer_queue8(u32 channel, u8 value);
-void sound_timer_queue16(u32 channel, u16 value);
-void sound_timer_queue32(u32 channel, u32 value);
+void sound_timer_queue32(u8 channel);
 void sound_timer(FIXED16_16 frequency_step, u32 channel);
 void sound_reset_fifo(u32 channel);
 void update_gbc_sound(u32 cpu_ticks);
@@ -122,7 +121,7 @@
 void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void sound_read_savestate(FILE_TAG_TYPE savestate_file);
 
-#define SOUND_FREQUENCY 44100
+// #define SOUND_FREQUENCY 44100
 
 #define gbc_sound_tone_control_low(channel, address)                          \
 {                                                                             \
@@ -137,7 +136,6 @@
   gbc_sound_channel[channel].envelope_initial_ticks = envelope_ticks;         \
   gbc_sound_channel[channel].envelope_ticks = envelope_ticks;                 \
   gbc_sound_channel[channel].envelope_status = (envelope_ticks != 0);         \
-  gbc_sound_channel[channel].envelope_volume = initial_volume;                \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, address) = value;                                   \
 }                                                                             \
@@ -147,7 +145,7 @@
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[channel].rate = rate;                                     \
   gbc_sound_channel[channel].frequency_step =                                 \
-   FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / SOUND_FREQUENCY);    \
+   FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / sound_frequency);    \
   gbc_sound_channel[channel].length_status = (value >> 14) & 0x01;            \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -157,6 +155,8 @@
      gbc_sound_channel[channel].envelope_initial_ticks;                       \
     gbc_sound_channel[channel].envelope_volume =                              \
      gbc_sound_channel[channel].envelope_initial_volume;                      \
+    gbc_sound_channel[channel].sweep_ticks =                                  \
+     gbc_sound_channel[channel].sweep_initial_ticks;                          \
   }                                                                           \
                                                                               \
   gbc_sound_update = 1;                                                       \
@@ -192,10 +192,12 @@
   ADDRESS16(io_registers, 0x70) = value;                                      \
 }                                                                             \
 
-extern u32 gbc_sound_wave_volume[4];
+// extern u32 gbc_sound_wave_volume[4];
 
 #define gbc_sound_tone_control_low_wave()                                     \
 {                                                                             \
+  u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };                    \
+                                                                              \
   gbc_sound_channel[2].length_ticks = 256 - (value & 0xFF);                   \
   if((value >> 15) & 0x01)                                                    \
   {                                                                           \
@@ -215,7 +217,7 @@
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[2].rate = rate;                                           \
   gbc_sound_channel[2].frequency_step =                                       \
-   FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / SOUND_FREQUENCY);           \
+   FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / sound_frequency);           \
   gbc_sound_channel[2].length_status = (value >> 14) & 0x01;                  \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -234,13 +236,13 @@
   {                                                                           \
     gbc_sound_channel[3].frequency_step =                                     \
      FLOAT_TO_FP16_16(1048576.0 / (1 << (frequency_shift + 1)) /              \
-     SOUND_FREQUENCY);                                                        \
+     sound_frequency);                                                        \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     gbc_sound_channel[3].frequency_step =                                     \
      FLOAT_TO_FP16_16(524288.0 / (dividing_ratio *                            \
-     (1 << (frequency_shift + 1))) / SOUND_FREQUENCY);                        \
+     (1 << (frequency_shift + 1))) / sound_frequency);                        \
   }                                                                           \
   gbc_sound_channel[3].noise_type = (value >> 3) & 0x01;                      \
   gbc_sound_channel[3].length_status = (value >> 14) & 0x01;                  \
@@ -258,13 +260,14 @@
 }                                                                             \
 
 #define gbc_trigger_sound_channel(channel)                                    \
-  gbc_sound_master_volume_right = value & 0x07;                               \
-  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
-  gbc_sound_channel[channel].status = ((value >> (channel + 8)) & 0x01) |     \
-   ((value >> (channel + 11)) & 0x03)                                         \
+  gbc_sound_channel[channel].status =                                         \
+  ((value >> (channel + 11)) & 0x02) | ((value >> (channel + 8)) & 0x01)      \
 
 #define gbc_trigger_sound()                                                   \
 {                                                                             \
+  gbc_sound_master_volume_right = value & 0x07;                               \
+  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
+                                                                              \
   gbc_trigger_sound_channel(0);                                               \
   gbc_trigger_sound_channel(1);                                               \
   gbc_trigger_sound_channel(2);                                               \
@@ -274,10 +277,11 @@
 
 #define trigger_sound()                                                       \
 {                                                                             \
-  timer[0].direct_sound_channels = (((value >> 10) & 0x01) == 0) |            \
-   ((((value >> 14) & 0x01) == 0) << 1);                                      \
-  timer[1].direct_sound_channels = (((value >> 10) & 0x01) == 1) |            \
-   ((((value >> 14) & 0x01) == 1) << 1);                                      \
+  timer[0].direct_sound_channels =                                            \
+   ((~value >> 13) & 0x02) | ((~value >> 10) & 0x01);                         \
+  timer[1].direct_sound_channels =                                            \
+   ((value >> 13) & 0x02) | ((value >> 10) & 0x01);                           \
+                                                                              \
   direct_sound_channel[0].volume = (value >> 2) & 0x01;                       \
   direct_sound_channel[0].status = (value >> 8) & 0x03;                       \
   direct_sound_channel[1].volume = (value >> 3) & 0x01;                       \
@@ -294,10 +298,7 @@
 #define sound_on()                                                            \
   if(value & 0x80)                                                            \
   {                                                                           \
-    if(sound_on != 1)                                                         \
-    {                                                                         \
-      sound_on = 1;                                                           \
-    }                                                                         \
+    sound_on = 1;                                                             \
   }                                                                           \
   else                                                                        \
   {                                                                           \
@@ -313,7 +314,7 @@
 
 #define sound_update_frequency_step(timer_number)                             \
   timer[timer_number].frequency_step =                                        \
-   FLOAT_TO_FP16_16(16777216.0 / (timer_reload * SOUND_FREQUENCY))            \
+   FLOAT_TO_FP16_16(16777216.0 / (timer_reload * sound_frequency))            \
 
 void reset_sound();
 void sound_exit();
diff -ru 30_orig/video.c 30_new/video.c
--- 30_orig/video.c	2007-08-26 00:49:54.947782600 +0900
+++ 30_new/video.c	2007-08-06 23:46:48.000000000 +0900
@@ -162,21 +162,13 @@
   CONVERT_PALETTE(current_pixel)                                              \
 
 #define tile_lookup_palette(palette, source)                                  \
-  current_pixel = palette[source];                                            \
+  current_pixel = palette[source]                                             \
 
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_expand_base_normal(index)                                        \
-  tile_expand_base_color16(index)                                             \
-
-#else
-
 #define tile_expand_base_normal(index)                                        \
   tile_lookup_palette(palette, current_pixel);                                \
   dest_ptr[index] = current_pixel                                             \
 
-#endif
 
 #define tile_expand_transparent_normal(index)                                 \
   tile_expand_base_normal(index)                                              \
@@ -621,20 +613,10 @@
 // Draws eight background pixels for the normal renderer, just a bunch of
 // zeros.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_4bpp_draw_eight_base_zero_normal()                               \
-  current_pixel = 0;                                                          \
-  tile_4bpp_draw_eight_base_zero(current_pixel)                               \
-
-#else
-
 #define tile_4bpp_draw_eight_base_zero_normal()                               \
   current_pixel = palette[0];                                                 \
   tile_4bpp_draw_eight_base_zero(current_pixel)                               \
 
-#endif
-
 
 // Draws eight 4bpp pixels.
 
@@ -698,7 +680,7 @@
 #define get_tile_4bpp()                                                       \
   current_tile = *map_ptr;                                                    \
   current_palette = (current_tile >> 12) << 4;                                \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32);                       \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32)                        \
 
 
 // Helper macro for drawing clipped 4bpp tiles.
@@ -955,6 +937,7 @@
   }                                                                           \
 }                                                                             \
 
+
 // If rendering a scanline that is not a target A then there's no point in
 // keeping what's underneath it because it can't blend with it.
 
@@ -967,19 +950,9 @@
   }                                                                           \
 
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_extra_variables_base_normal(bg_type)                  \
-  const u32 pixel_combine = 0                                                 \
-
-#else
-
 #define render_scanline_extra_variables_base_normal(bg_type)                  \
   u16 *palette = palette_ram_converted                                        \
 
-#endif
-
-
 #define render_scanline_extra_variables_base_alpha(bg_type)                   \
   u32 bg_combine = color_combine_mask(5);                                     \
   u32 pixel_combine = color_combine_mask(layer) | (bg_combine << 16);         \
@@ -1450,30 +1423,13 @@
   else                                                                        \
     src_ptr = (u16 *)vram                                                     \
 
-
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_vram_setup_mode4()                                    \
-  const u32 pixel_combine = 0;                                                \
-  u8 *src_ptr;                                                                \
-  if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
-  else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-
-#else
-
 #define render_scanline_vram_setup_mode4()                                    \
   u16 *palette = palette_ram_converted;                                       \
   u8 *src_ptr;                                                                \
   if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
+    src_ptr = vram + 0xA000;                                                  \
   else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-#endif
-
+    src_ptr = vram                                                            \
 
 
 // Build bitmap scanline rendering functions.
@@ -1738,7 +1694,7 @@
 
 #define obj_render_scale_pixel_8bpp(combine_op, alpha_op)                     \
   current_pixel = tile_ptr[tile_map_offset + (tile_x & 0x07)];                \
-  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op);                          \
+  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op)                           \
 
 #define obj_render_scale(combine_op, color_depth, alpha_op, map_space)        \
 {                                                                             \
@@ -1923,19 +1879,9 @@
 
 // Build obj rendering functions
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_obj_extra_variables_normal(bg_type)                   \
-  const u32 pixel_combine = (1 << 8)                                          \
-
-#else
-
 #define render_scanline_obj_extra_variables_normal(bg_type)                   \
   u16 *palette = palette_ram_converted + 256                                  \
 
-#endif
-
-
 #define render_scanline_obj_extra_variables_color()                           \
   u32 dest;                                                                   \
   u32 pixel_combine = color_combine_mask(4) | (1 << 8)                        \
@@ -2173,7 +2119,6 @@
     obj_attribute_0 = oam_ptr[0];
     obj_attribute_2 = oam_ptr[2];
     obj_size = obj_attribute_0 & 0xC000;
-    obj_priority = (obj_attribute_2 >> 10) & 0x03;
     obj_mode = (obj_attribute_0 >> 10) & 0x03;
 
     if(((obj_attribute_0 & 0x0300) != 0x0200) && (obj_size != 0xC000) &&
@@ -2186,6 +2131,7 @@
 
       obj_attribute_1 = oam_ptr[1];
       obj_size = ((obj_size >> 12) & 0x0C) | (obj_attribute_1 >> 14);
+      obj_priority = (obj_attribute_2 >> 10) & 0x03;
       obj_height = obj_height_table[obj_size];
       obj_width = obj_width_table[obj_size];
 
@@ -2331,10 +2277,10 @@
   }                                                                           \
 
 #define brighten_pixel()                                                      \
-  pixel_top = upper + ((pixel_top * blend) >> 4);                             \
+  pixel_top = upper + ((pixel_top * blend) >> 4)                              \
 
 #define darken_pixel()                                                        \
-  pixel_top = (pixel_top * blend) >> 4;                                       \
+  pixel_top = (pixel_top * blend) >> 4                                        \
 
 #define effect_condition_alpha                                                \
   ((pixel_pair & 0x04000200) == 0x04000200)                                   \
@@ -2422,32 +2368,8 @@
 
 // Blend top two pixels of scanline with each other.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-void expand_normal(u16 *screen_ptr, u32 start, u32 end)
-{
-  u32 i, pixel_source;
-  screen_ptr += start;
-
-  return;
-
-  end -= start;
-
-  for(i = 0; i < end; i++)
-  {
-    pixel_source = *screen_ptr;
-    *screen_ptr = palette_ram_converted[pixel_source];
-
-    screen_ptr++;
-  }
-}
-
-#else
-
 #define expand_normal(screen_ptr, start, end)
 
-#endif
-
 void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
@@ -3399,16 +3321,16 @@
   gecb.finish_arg = NULL;
   gecbid = sceGeSetCallback(&gecb);
 
-  screen_vertex[0] = 0 + 0.5;
-  screen_vertex[1] = 0 + 0.5;
-  screen_vertex[2] = 0 + 0.5;
-  screen_vertex[3] = 0 + 0.5;
-  screen_vertex[4] = 0;
+  screen_vertex[0] = 0.0 + 0.5;
+  screen_vertex[1] = 0.0 + 0.5;
+  screen_vertex[2] = 0.0 + 0.5;
+  screen_vertex[3] = 0.0 + 0.5;
+  screen_vertex[4] = 0.0;
   screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
   screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
   screen_vertex[7] = PSP_SCREEN_WIDTH - 0.5;
   screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
-  screen_vertex[9] = 0;
+  screen_vertex[9] = 0.0;
 
   // Set framebuffer to PSP VRAM
   GE_CMD(FBP, ((u32)psp_gu_vram_base & 0x00FFFFFF));
@@ -3471,24 +3393,36 @@
   switch(scale)
   {
     case unscaled:
-      screen_vertex[2] = 120 + 0.5;
-      screen_vertex[3] = 56 + 0.5;
-      screen_vertex[7] = GBA_SCREEN_WIDTH + 120 - 0.5;
-      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56 - 0.5;
+      screen_vertex[0] = 0.0;
+      screen_vertex[1] = 0.0;
+      screen_vertex[2] = 120.0;
+      screen_vertex[3] = 56.0;
+      screen_vertex[5] = (float)GBA_SCREEN_WIDTH;
+      screen_vertex[6] = (float)GBA_SCREEN_HEIGHT;
+      screen_vertex[7] = GBA_SCREEN_WIDTH + 120.0;
+      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56.0;
       break;
 
     case scaled_aspect:
-      screen_vertex[2] = 36 + 0.5;
-      screen_vertex[3] = 0 + 0.5;
-      screen_vertex[7] = 408 + 36 - 0.5;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 36.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = 408.0 + 36.0;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
 
     case fullscreen:
-      screen_vertex[2] = 0;
-      screen_vertex[3] = 0;
-      screen_vertex[7] = PSP_SCREEN_WIDTH;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 0.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = (float)PSP_SCREEN_WIDTH;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
   }
 
diff -ru 30_orig/zip.c 30_new/zip.c
--- 30_orig/zip.c	2007-08-26 00:49:54.922782600 +0900
+++ 30_new/zip.c	2007-08-06 23:45:44.000000000 +0900
@@ -44,7 +44,7 @@
   s16 ExtraFieldLength;
 }  __attribute__((packed));
 
-u32 load_file_zip(char *filename)
+s32 load_file_zip(char *filename)
 {
   struct SZIPFileHeader data;
   char tmp[1024];
@@ -123,6 +123,7 @@
 
           stream.zalloc = (alloc_func)0;
           stream.zfree = (free_func)0;
+          stream.opaque = (voidpf)0;
 
           err = inflateInit2(&stream, -MAX_WBITS);
 
diff -ru 30_orig/zip.h 30_new/zip.h
--- 30_orig/zip.h	2007-08-26 00:49:54.966782600 +0900
+++ 30_new/zip.h	2007-08-06 23:45:26.000000000 +0900
@@ -21,7 +21,7 @@
 #ifndef ZIP_H
 #define ZIP_H
 
-u32 load_file_zip(char *filename);
+s32 load_file_zip(char *filename);
 
 #endif
 
